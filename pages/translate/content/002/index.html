<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title># Choosing a Lighting Technique | Notes.HF</title>
  <meta name="author" content="HuFei">
  
  <meta name="description" content="Notes of Daily Learning">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="# Choosing a Lighting Technique"/>
  <meta property="og:site_name" content="Notes.HF"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Notes.HF" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
  
</head>

<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Notes.HF</a></h1>
  <h2><a href="/">notes of buaaGS1521AA9.hufei | 笔记 · 专注 3D 游戏开发</a></h2>
</div>
<nav id="main-nav">
  <ul>
    
      <li><a href="/pages/unity3d">Unity</a></li>
    
      <li><a href="/pages/unreal">Unreal</a></li>
    
      <li><a href="/pages/shader">Shader</a></li>
    
      <li><a href="/pages/graphics">CG</a></li>
    
      <li><a href="/pages/cpp">C++</a></li>
    
      <li><a href="/pages/virtualreality">VR</a></li>
    
      <li><a href="/pages/translate">翻译</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
<div class="alignleft" style="margin-top: 15px">


  <iframe src="http://ghbtns.com/github-btn.html?user=Isayes&type=follow"
  allowtransparency="true" frameborder="0" scrolling="0" width="132" height="20"></iframe>

</div>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="wrapper"><article class="page">
  
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/pages/translate/content/002/index.html"># Choosing a Lighting Technique</a></h1>
  

      
    </header>
    <div class="entry">
      
        <h1 id="选择一种光照技术"><a href="#选择一种光照技术" class="headerlink" title="# 选择一种光照技术"></a># 选择一种光照技术</h1><p>Broadly speaking, lighting in Unity can be considered as either ‘realtime’ or ‘precomputed’ in some way and both techniques can be used in combination to create immersive scene lighting.</p>
<p>广义上说，Unity 中光照既可以是“实时的”也可以是“预计算的”，而且这两种技术可以结合使用，从而创建出一个仿真的场景照明。</p>
<p>In this section we will give a brief overview of what opportunities the different techniques offer, their relative advantages and individual performance characteristics.</p>
<p>在本节中，我们将会简要概述这两种不同技术所能提供的使用时机，和它们相对的优势以及独特的性能特征。</p>
<h2 id="Realtime-Lighting-实时光照"><a href="#Realtime-Lighting-实时光照" class="headerlink" title="## Realtime Lighting 实时光照"></a>## Realtime Lighting 实时光照</h2><p>By default, lights in Unity - directional, spot and point, are realtime. This means that they contribute direct light to the scene and update every frame. As lights and GameObjects are moved within the scene, lighting will be updated immediately. This can be observed in both the scene and game views.</p>
<p>默认情况下，Unity 中的平行光，聚光灯，点光源都是实时的。这意味着它们直接发射光束到场景中并且每一帧都被更新。当灯光和 GameObjects 在场景内移动，灯光也就会立即被更新，我们可以在场景视图和游戏视图中观察之。</p>
<p><img src="https://unity3d.com/sites/default/files/realtime_0.png" alt=""></p>
<p>（The effect of realtime light alone. Note that shadows are completely black as there is no bounced light. Only surfaces falling within the cone of the Spotlight are affected.）</p>
<p>（单独使用实时光照的效果。注意到阴影是完全黑的因为没有反射光。 只有聚光灯圆锥里面以下的表面是受影响的。）</p>
<p>Realtime lighting is the most basic way of lighting objects within the scene and is useful for illuminating characters or other movable geometry.</p>
<p>实时光照是在场景中照亮物体最基础的方式，对照亮人物角色或其他可移动的几何体非常有用。</p>
<p>Unfortunately, the light rays from Unity’s realtime lights do not bounce when they are used by themselves. In order to create more realistic scenes using techniques such as global illumination we need to enable Unity’s precomputed lighting solutions.</p>
<p>不幸的是，Unity 实时灯光在使用自己的时候发射出的光线不会进行反射。 为了使用诸如全局光照的技术创建更加真实的场景效果，就要考虑 Unity 光照预计算的解决方案了。</p>
<h2 id="Baked-GI-Lighting-烘焙全局光照"><a href="#Baked-GI-Lighting-烘焙全局光照" class="headerlink" title="## Baked GI Lighting 烘焙全局光照"></a>## Baked GI Lighting 烘焙全局光照</h2><p>When ‘baking’ a ‘lightmap’, the effects of light on static objects in the scene are calculated and the results are written to textures which are overlaid on top of scene geometry to create the effect of lighting.</p>
<p>当”烘焙”一个“光照贴图”的时候，场景中在静态物体上光照的效果要被计算，计算结果被写入纹理，该纹理在场景几何体的顶部进行覆盖以创建出照明的效果。</p>
<p><img src="https://unity3d.com/sites/default/files/lightmap.jpg" alt=""></p>
<p>（Left: A simple lightmapped scene. Right: The lightmap texture generated by Unity. Note how both shadow and light information is captured.）</p>
<p>（左图：一个简单的进行过光照贴图的场景。 右图：Unity 生成的光照贴图的纹理。 注意阴影和光照信息是如何被捕捉的。）</p>
<p>These ‘lightmaps’ can include both the direct light which strikes a surface and also the ‘indirect’ light that bounces from other objects or surfaces within the scene. This lighting texture can be used together with surface information like color (albedo) and relief (normals) by the ‘Shader’ associated with an object’s material.</p>
<p>这些“光照贴图” 可以既包括一个物体发射出的直接光照，也包括从其他物体或场景内表面反射出的“非直接”光照。 这种光照纹理可以和表面信息一起使用，这个关联物体材质 Material 的着色器 Shader 的表面信息可以有颜色（color）、法线（normals）等等。</p>
<p>With baked lighting, these light textures (lightmaps) cannot change during gameplay and so are referred to as ‘static’. Realtime lights can be overlaid and used additively on top of a lightmapped scene but cannot interactively change the lightmaps themselves.</p>
<p>通过烘焙光照，这些照明纹理（光照贴图）在游戏运行过程中无法被改变，也因此被称为“静态”的。 实时光照可以被覆盖并且能够在一个使用过光照贴图的场景的顶部叠加使用，不过无法交互式地改变光照贴图本身。</p>
<p>With this approach, we trade the ability to move our lights at gameplay for a potential increase in performance, suiting less powerful hardware such as mobile platforms.</p>
<p>通过这个方法，我们拥有了在游戏运行过程中移动光照的能力，潜在地增加了性能，适合能力更弱的硬件比如说移动平台。</p>
<h2 id="Precomputed-Realtime-GI-Lighting-预计算的实时光照"><a href="#Precomputed-Realtime-GI-Lighting-预计算的实时光照" class="headerlink" title="## Precomputed Realtime GI Lighting 预计算的实时光照"></a>## Precomputed Realtime GI Lighting 预计算的实时光照</h2><p>Whilst traditional, static lightmaps are unable to react to changes in lighting conditions within the scene, Precomputed Realtime GI does offer us a technique for updating complex scene lighting interactively.</p>
<p>对于传统的静态光照贴图，无法应对在场景中光照条件的变化，预计算实时光照的确为我们提供了可以升级复杂场景交互式光照的技术。</p>
<p>With this approach it is possible to create lit environments featuring rich global illumination with bounced light which responds, in realtime, to lighting changes. A good example of this would be a time of day system - where the position and color of the light source changes over time. With traditional baked lighting, this is not possible.</p>
<p>使用这个方法，能够创建灯光环境，能够操作特点丰富的实时变化带有反射的全局光照，一天的时间系统是一个好例子，光的位置和颜色是在全天候变化的。 而传统的烘焙光照这点是无法做到的。</p>
<p><img src="https://unity3d.com/sites/default/files/timeofdaycycle.gif" alt=""></p>
<p>（A simple example of time of day using Precomputed Realtime GI.）</p>
<p>（一个简单的例子：使用了预计算实时全局光照技术的一天时光。）</p>
<p>In order to deliver these effects at playable framerates, we need to shift some of the lengthy number-crunching from being a realtime process, to one which is ‘precomputed’.</p>
<p>为了在可播放帧率的时候实现这些效果，我们需要将一些冗长的数据从一个实时过程的方式转变成一个做“预计算”的处理。</p>
<p>Precomputing shifts the burden of calculating complex light behaviour from something that happens during gameplay, to something which can be calculated when time is no longer so critical. We refer to this as an ‘offline’ process.</p>
<p>预计算把计算复杂光照行为的负担做了转换，即从游戏运行过程中转换到对时间不再如此苛刻的时候计算。我们称之为一个“离线”的过程。</p>
<p>So how does this work?</p>
<p>所以这是如何工作的呢？</p>
<p>Most frequently it is indirect (bounced) light that we want to store in our lightmaps when trying to create realism in our scene lighting. Fortunately, this tends to be soft with few sharp, or ‘high frequency’ changes in color. Unity’s Precomputed Realtime GI solution exploits these ‘diffuse’ characteristics of indirect light to our advantage.</p>
<p>最常见的是当尝试创建出仿真的场景光照的时候我们想要在我们的光照贴图中存储反射的间接光。幸运地是，这种往往是比较柔和的，很少有尖锐的“高频”的颜色变化。</p>
<p>Finer lighting details, such as crisp shadowing, are usually better generated with realtime lights rather than baking them into lightmaps. By assuming we don’t need to capture these intricate details we can greatly reduce the resolution of our global illumination solution.</p>
<p>更好的光照细节，比如具有 crisp 特点的阴影，通常更适合使用实时光照而不是将其烘焙进光照贴图。通过假设我们不需要捕获这些错综复杂的细节，我们可以大大减少使用全局光照的方案。</p>
<p>By making this simplification during the precompute, we effectively reduce the number of calculations we need to make in order to update our GI lighting during gameplay. This is important if we were to change properties of our lights - such as color, rotation or intensity, or even make change to surfaces in the scene.</p>
<p>通过在预计算期间进行简化，我们可以有效地减少所需要计算的次数，从而更新我们在游戏运行期间的全局光照。如果我们打算改变光照的属性，这点很重要，例如颜色、旋转或者强度，甚至场景中的表面变化。</p>
<p>To speed up the precompute further Unity doesn’t directly work on lightmaps texels, but instead creates a low resolution approximation of the static geometry in the world, called ‘clusters’.</p>
<p>为了进一步加速预计算的速度，Unity 不直接在光照贴图的纹素上工作，而是在世界上创建了一种低分辨率的静态几何图形，称之为“集群”。</p>
<p><img src="https://unity3d.com/sites/default/files/albedo.png" alt=""></p>
<p>（Left: With scene view set to ‘Albedo’ the texels generated by Unity’s Precomputed Realtime GI can clearly be seen. By default a texel in this view is roughly the size of a cluster. Right: The scene as it appears in-game once the lighting has been calculated and the results converted to lightmap textures and applied. Traditionally when calculating global illumination, we would ‘ray trace’ light rays as they bounce around the static scene. This is very processing intensive and therefore too demanding to be updated in realtime. Instead, Unity uses ray tracing to calculate the relationships between these surface clusters beforehand - during the ‘Light Transport’ stage of the precompute.）</p>
<p>（左图：被 Unity 实时全局光照生成的场景视图设置的纹素能够清晰可见。 默认情况下，在这个视图的一个纹素与集群差不多大小。 // 右图：在游戏中的场景，一旦灯光被计算出来，结果就会转化为光照贴图的纹理并且被应用。传统上，当计算全局光照的时候，我们可以对静态场景中的反射光线进行追踪。这点是个非常重要的过程，也因此要求其进行实时的更新。相反地，Unity 使用射线追踪来计算这些表面集群之间的关系 —— 在预计算的“光传输”阶段。）</p>
<p>By simplifying the world into a network of relationships, we remove the need for expensive ray tracing during the performance-critical gameplay processes.</p>
<p>通过将世界简化为一个关系网络，我们去除了在关键性能的游戏过程中对昂贵的射线追踪的需求。</p>
<p>We have effectively created a simplified mathematical model of the world which can be fed different input during gameplay. This means we can make modifications to lights, or surface colors within the scene and quickly see the effects of GI in scene lighting update at interactive framerates. The resulting output from our lighting model can then be turned into lightmap textures for rendering on the GPU, blended with other lighting and surface maps, processed for effects and finally output to the screen.</p>
<p>我们有效地创建了一个简化的世界数学模型，该模型可以在游戏过程中进行不同的输入。这意味着我们可以对光照进行修改，或者对场景中的表面颜色进行修改，并快速看到在交互式帧率中更新的 GI 在场景中的效果。从我们的光照模型中输出的结果能够被转化为光照贴图纹理，在 GPU 上渲染，和其他光照及表面贴图混合，处理出效果并且最终输出到屏幕上。</p>
<h2 id="Benefits-and-Costs-收益和成本"><a href="#Benefits-and-Costs-收益和成本" class="headerlink" title="## Benefits and Costs 收益和成本"></a>## Benefits and Costs 收益和成本</h2><p>Although it is possible to simultaneously use Baked GI lighting and Precomputed Realtime GI, be wary that the performance cost of rendering both systems simultaneously is exactly the sum of them both. Not only do we have to store both sets of lightmaps in video memory, but we also pay the processing cost of decoding both in shaders.</p>
<p>虽然可以同时使用烘焙 GI 照明和预计算实时 GI，但是要注意的是，同时渲染两种方式的性能成本是两者的总和。我们不仅要在视频存储器中存储两组光照贴图，还要为两者都要在着色器中解码付出代价。</p>
<p>The cases in which you may wish to choose one lighting method over another depend on the nature of your project and the performance capabilities of your intended hardware. For example, on mobile where video memory and processing power is more limited, it is likely that a Baked GI lighting approach would be more performant. On ‘standalone computers’ with dedicated graphics hardware, or recent games consoles, it is quite possible to use Precomputed Realtime GI or even to use both systems simultaneously.</p>
<p>在你希望选择一种光照方式而不是另一种的时候取决于项目的性质和目标硬件的性能。例如，在手机上，它的视频内存和处理能力均有限，可能采用烘焙全局光照的方式是一个更好的选择。 而在独立计算机上，有着专用的计算机图形硬件，或者近年来的游戏单机，却很有可能使用预计算的实时全局光照 GI 甚至是两种光照模式都使用了。</p>
<p>The decision on which approach to take will have to be evaluated based on the nature of your particular project and desired target platform. Remember that when targeting a range of different hardware, that often it is the least performant which will determine which approach is needed.</p>
<p>要根据你的特定项目的性质和目标平台来评估一下决定采用哪种方式。 要记住，当对不同的硬件进行定位的时候，通常会采用最低性能的部分决定采用哪一种方案是被需要的。</p>
<h2 id="Enabling-Baked-GI-or-Precomputed-Realtime-GI-采用烘焙全局光照或者预计算实时全局光照"><a href="#Enabling-Baked-GI-or-Precomputed-Realtime-GI-采用烘焙全局光照或者预计算实时全局光照" class="headerlink" title="## Enabling Baked GI or Precomputed Realtime GI 采用烘焙全局光照或者预计算实时全局光照"></a>## Enabling Baked GI or Precomputed Realtime GI 采用烘焙全局光照或者预计算实时全局光照</h2><p>By default, both Precomputed Realtime GI and Baked GI are enabled in Unity’s Lighting panel (Lighting&gt;Scene). With both enabled, which technique is used can then be controlled by each light individually (Inspector&gt;Light&gt;Baking).</p>
<p>默认情况下，在 Unity 的光照面板（Lighting&gt;Scene）中预计算实时全局光照和烘焙全局光照都可以被使用。 如此情况下，哪一种技术被使用可以单独地由每一个光照来控制（Inspector&gt;Light&gt;Baking）。</p>
<h2 id="Per-Light-Settings-Per-Light-设置"><a href="#Per-Light-Settings-Per-Light-设置" class="headerlink" title="## Per-Light Settings Per-Light 设置"></a>## Per-Light Settings Per-Light 设置</h2><p>The default baking mode for each light is ‘Realtime’. This means that the selected light(s) will still contribute direct light to your scene, with indirect light handled by Unity’s Precomputed Realtime GI system.</p>
<p>每一个光照的默认烘焙模式是“实时”的。这意味着所选择的光将会依然为你的场景提供直接的光，和预计算实时全局光照系统处理过的间接光一起。</p>
<p>However, if the baking mode is set to ‘Baked’ then that light will contribute lighting solely to Unity’s Baked GI system. Both direct and indirect light from those lights selected will be ‘baked’ into lightmaps and cannot be changed during gameplay.</p>
<p>然而，如果烘焙模式被设定为“Baked”，那么光照将会单独地为 Unity 的烘焙全局光照系统提供光照。 这些光照的直接和间接光将会被烘焙进光照贴图并且在游戏运行过程无法被改变。</p>
<p><img src="https://unity3d.com/sites/default/files/lightbakingmode_2.png" alt=""></p>
<p>（Point light with the per-light Baking mode set to ‘Realtime’.）</p>
<p>（带有 per-light 烘焙模式的点光源被设置成“实时”）</p>
<p>Selecting the ‘Mixed’ baking mode, GameObjects marked as static will still include this light in their Baked GI lightmaps. However, unlike lights marked as ‘Baked’, Mixed lights will still contribute realtime, direct light to non-static GameObjects within your scene. This can be useful in cases where you are using lightmaps in your static environment, but you still want a character to use these same lights to cast realtime shadows onto lightmapped geometry.</p>
<p>选择“混合”的烘焙模式，GameObject 被标记成静态的，在它们的烘焙GI光照贴图里包含着这个光线。 然而，不同于被标记为“烘焙”的灯光， 混合光照将会提供实时的光线给你场景中的非静态游戏对象。这对于当在你在静态环境中使用光照贴图的情况下很有用，但是你依然需要一个角色来使用这些相同的光线以将实时阴影投射到光照贴图过的几何体上。</p>
<p>End.</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>
<!-- hackish -->
</div>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2017 HuFei
  
</div>
<div class="clearfix"></div></footer>
  <script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="http://apps.bdimg.com/libs/fancybox/2.1.5/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>