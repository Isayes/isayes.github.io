<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title># 关于 Android RxJava 首先需要知道的几点 | Notes.HF</title>
  <meta name="author" content="HuFei">
  
  <meta name="description" content="Notes of Daily Learning">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="# 关于 Android RxJava 首先需要知道的几点"/>
  <meta property="og:site_name" content="Notes.HF"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Notes.HF" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
  
</head>

<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Notes.HF</a></h1>
  <h2><a href="/">notes of buaaGS1521AA9.hufei | 用来笔记一下</a></h2>
</div>
<nav id="main-nav">
  <ul>
    
      <li><a href="/more">分类</a></li>
    
      <li><a href="/works">作品</a></li>
    
      <li><a href="http://www.cnblogs.com/isayes">博客</a></li>
    
      <li><a href="http://weibo.com/khufly">微博</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
<div class="alignleft" style="margin-top: 15px">


  <iframe src="http://ghbtns.com/github-btn.html?user=Isayes&type=follow"
  allowtransparency="true" frameborder="0" scrolling="0" width="132" height="20"></iframe>

</div>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="wrapper"><article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
  
    <h1 class="title"># 关于 Android RxJava 首先需要知道的几点</h1>
  

      
        <p class="published">
          Published: <time datetime="2016-06-01T04:40:02.000Z">2016-06-01</time>
        </p>
      
    </header>
    <div class="entry">
      
        <p>关键词：学习计划 / RxJava / 观察者模式 / 异步 / 响应式</p>
<p>本次笔记梳理了对 RxJava 的初步认识以及学习规划，其实之前年初就在微博上看到过很多大牛在刷屏，当时也只是稍微看了看他们写的文章，并没有深入了解，现在看来如果不掌握 RxJava 都不好意思去找工作了… 听说，RxJava 可以在开发安卓 App 时，作为一个强大的处理并发的工具使用，越是了解它，你就越会爱上它？！虽然要熟悉它还是需要一些时间，但是话说磨刀不误砍柴工，一旦掌握了它，将会带来很大帮助。响应式扩展库是个很好的想法，可以把它用于安卓程序的开发，产品的异步任务处理可以完全基于它完成。如果没有 Rx，我们需要创建 N 个线程去调用请求，然后通过异步方式把处理结果交给 UI 线程。使用 Rx 只需编写很少的代码就完成工作，使用它强大的功能创建、合并、过滤和转化 Observable 对象。</p>
<a id="more"></a>
<h2 id="1-什么是-RxJava"><a href="#1-什么是-RxJava" class="headerlink" title="[1] 什么是 RxJava #"></a>[1] 什么是 RxJava #</h2><p>RxJava 是由 Netflix 开发的响应式扩展（Reactive Extensions）的 Java 实现。</p>
<ol>
<li>异步操作。RxJava 是一个在 Java VM 上使用可观测的序列来组成<strong>异步的</strong>、基于<strong>事件</strong>的程序的<strong>库</strong>；(A library for composing asynchronous and event-based programs using observable sequences for the Java VM.)，概括：RxJava 是一个实现异步操作的库；</li>
<li>逻辑简洁。体现在，相比于 AsyncTask 和 Handler，RxJava 随着程序逻辑变得越来越复杂，依然能够<strong>保持简洁</strong>。 RxJava 只是一条从上到下的链式调用，没有任何嵌套调用就完成了。即使它很长，但很清晰。</li>
<li>RxJava 最核心的两个东西是 Observables（被观察者，事件源）和Subscribers（观察者 observer）。Observables 发出一系列事件，Subscribers 处理这些事件。这里的事件可以是任何你感兴趣的东西（触摸事件，web 接口调用返回的数据。。。）</li>
</ol>
<p>[ RxJava 的基本实现有三点：]</p>
<p>（1）创建 Observer。即创建观察者，它决定事件触发的时候将有怎样的行为。RxJava 的事件回调方法除了普通事件 onNext() （相当于 onClick() / onEvent()）之外，还定义了两个特殊的事件：onCompleted() 和 onError()。下面是 RxJava 中的 Observer 接口的实现方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Observer&lt;String&gt; observer = <span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Log.d(tag, <span class="string">"Item: "</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(tag, <span class="string">"Completed!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        Log.d(tag, <span class="string">"Error!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>除了 Observer 接口之外，RxJava 还内置了一个实现了 Observer 的抽象类：Subscriber。 Subscriber 对 Observer 接口进行了一些扩展，但他们的基本使用方式是完全一样的，不仅基本使用方式一样，实质上，在 RxJava 的 subscribe 过程中，Observer 也总是会先被转换成一个 Subscriber 再使用。所以如果你只想使用基本功能，选择 Observer 和 Subscriber 是完全一样的。    </p>
<p>（2）创建 Observable，即被观察者，它决定什么时候触发事件以及触发怎么样的事件。RxJava 使用 create() 方法来创建一个 Observable ，并为它定义事件触发规则。create() 方法是 RxJava 最基本的创造事件序列的方法。create() 方法传入了一个 OnSubscribe 对象作为参数。OnSubscribe 会被存储在返回的 Observable 对象中，它的作用相当于一个计划表，当 Observable 被订阅的时候，OnSubscribe 的 call() 方法会自动被调用，事件序列就会依照设定依次触发。这样，由被观察者调用了观察者的回调方法，就实现了由被观察者向观察者的事件传递，即观察者模式。基于create() 这个方法， RxJava 还提供了一些方法用来快捷创建事件队列<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line">Observable observable = Observable.just(<span class="string">"Hello"</span>, <span class="string">"Hi"</span>, <span class="string">"Aloha"</span>);</span><br><span class="line"><span class="comment">// 将会依次调用：</span></span><br><span class="line"><span class="comment">// onNext("Hello");</span></span><br><span class="line"><span class="comment">// onNext("Hi");</span></span><br><span class="line"><span class="comment">// onNext("Aloha");</span></span><br><span class="line"><span class="comment">// onCompleted();</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line">String[] words = &#123;<span class="string">"Hello"</span>, <span class="string">"Hi"</span>, <span class="string">"Aloha"</span>&#125;;</span><br><span class="line">Observable observable = Observable.from(words);</span><br><span class="line"><span class="comment">// 将会依次调用：</span></span><br><span class="line"><span class="comment">// onNext("Hello");</span></span><br><span class="line"><span class="comment">// onNext("Hi");</span></span><br><span class="line"><span class="comment">// onNext("Aloha");</span></span><br><span class="line"><span class="comment">// onCompleted();</span></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line">Observable observable = Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;</span><br><span class="line">        subscriber.onNext(<span class="string">"Hello"</span>);</span><br><span class="line">        subscriber.onNext(<span class="string">"Hi"</span>);</span><br><span class="line">        subscriber.onNext(<span class="string">"Aloha"</span>);</span><br><span class="line">        subscriber.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>（3）用 Subscribe() 方法（订阅）将它们连结起来，即可以工作了。流式 API 的设计<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">observable.subscribe(observer);</span><br><span class="line"><span class="comment">// 或者：</span></span><br><span class="line">observable.subscribe(subscriber);</span><br></pre></td></tr></table></figure></p>
<p>Scheduler：</p>
<p>在 RxJava 的默认规则中，事件的发出和消费都是在同一个线程的。观察者模式本身的目的就是『<strong>后台处理，前台回调</strong>』的<strong>异步机制</strong>，因此异步对于 RxJava 是至关重要的。而要实现异步，则需要用到 RxJava 的另一个概念： Scheduler 。</p>
<p>在不指定线程的情况下， RxJava 遵循的是线程不变的原则，即：在哪个线程调用 subscribe()，就在哪个线程生产事件；在哪个线程生产事件，就在哪个线程消费事件。如果需要切换线程，就需要用到 Scheduler （调度器）。在RxJava 中，Scheduler ——调度器，相当于线程控制器，RxJava 通过它来指定每一段代码应该运行在什么样的线程。</p>
<p>[ 变换： ]</p>
<p>RxJava 提供了对事件序列进行变换的支持，这是它的核心功能之一，也是大多数人说『RxJava 真是太好用了』的最大原因。<strong>所谓变换，就是将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列</strong>。</p>
<p>[ 变换的原理：lift() ]</p>
<p>这些变换虽然功能各有不同，但实质上都是<strong>针对事件序列的处理和再发送</strong>。而在 RxJava 的内部，它们是基于同一个基础的变换方法： lift(Operator)</p>
<p>[ compose: 对 Observable 整体的变换：]</p>
<p>除了 lift() 之外，Observable 还有一个变换方法叫做 compose(Transformer)。它和 lift() 的区别在于， lift() 是针对事件项和事件序列的，而 compose() 是针对 Observable 自身进行变换。</p>
<p><code>--- 并不华丽的分割线 ---</code></p>
<p>除了灵活的变换，RxJava 另一个牛逼的地方，就是线程的自由控制。</p>
<p>利用 subscribeOn() 结合 observeOn() 来实现线程控制，让事件的产生和消费发生在不同的线程。可是在了解了 map() flatMap() 等变换方法后，能不能多切换几次线程？</p>
<p>答案是：能。因为 observeOn() 指定的是 Subscriber 的线程，而这个 Subscriber 并不是（严格说应该为『不一定是』，但这里不妨理解为『不是』）subscribe() 参数中的 Subscriber ，而是 observeOn() 执行时的当前 Observable 所对应的 Subscriber，即它的直接下级 Subscriber 。换句话说，observeOn() 指定的是它之后的操作所在的线程。因此如果有多次切换线程的需求，只要在每个想要切换线程的位置调用一次 observeOn() 即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) <span class="comment">// IO 线程，由 subscribeOn() 指定</span></span><br><span class="line">    .subscribeOn(Schedulers.io())</span><br><span class="line">    .observeOn(Schedulers.newThread())</span><br><span class="line">    .map(mapOperator) <span class="comment">// 新线程，由 observeOn() 指定</span></span><br><span class="line">    .observeOn(Schedulers.io())</span><br><span class="line">    .map(mapOperator2) <span class="comment">// IO 线程，由 observeOn() 指定</span></span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread) </span><br><span class="line">    .subscribe(subscriber);  <span class="comment">// Android 主线程，由 observeOn() 指定</span></span><br></pre></td></tr></table></figure>
<p>如上，通过 observeOn() 的多次调用，程序实现了线程的多次切换。</p>
<h2 id="2-RxJava-的适用场景和使用方式"><a href="#2-RxJava-的适用场景和使用方式" class="headerlink" title="[2] RxJava 的适用场景和使用方式 #"></a>[2] RxJava 的适用场景和使用方式 #</h2><ol>
<li>Retrofit 是 Square 的一个著名的网络请求库。Retrofit 除了提供了传统的 Callback 形式的 API，还有 RxJava 版本的 Observable 形式 API。<br>使用 RxJava 形式的 API，定义同样的请求是这样的</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GET</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Observable&lt;User&gt; <span class="title">getUser</span><span class="params">(@Query(<span class="string">"userId"</span>)</span> String userId)</span>;</span><br></pre></td></tr></table></figure>
<p>使用的时候是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">getUser(userId)</span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">    .subscribe(<span class="keyword">new</span> Observer&lt;User&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">            userView.setUser(user);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable error)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Error handling</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>当 RxJava 形式的时候，Retrofit 把请求封装进 Observable ，在请求结束后调用 onNext() 或在请求失败后调用 onError()。</p>
<ol>
<li>RxBinding 是 Jake Wharton 的一个开源库，它提供了一套在 Android 平台上的基于 RxJava 的 Binding API。所谓 Binding，就是类似设置 OnClickListener 、设置 TextWatcher 这样的注册绑定对象的 API。</li>
<li>各种异步操作。前面举的 Retrofit 和 RxBinding 的例子，是两个可以提供现成的 Observable 的库。而如果你有某些异步操作无法用这些库来自动生成 Observable，也完全可以自己写。例如数据库的读写、大图片的载入、文件压缩/解压等各种需要放在后台工作的耗时操作，都可以用 RxJava 来实现。</li>
<li>RxBus。RxBus 名字看起来像一个库，但它并不是一个库，而是一种模式，它的思想是使用 RxJava 来实现了 EventBus ，而让你不再需要使用 Otto 或者 GreenRobot 的 EventBus。至于什么是 RxBus，可以看<a href="http://nerds.weddingpartyapp.com/tech/2014/12/24/implementing-an-event-bus-with-rxjava-rxbus/" target="_blank" rel="external">这篇文章</a>。</li>
</ol>
<h2 id="3-学会-RxJava-计划"><a href="#3-学会-RxJava-计划" class="headerlink" title="[3] 学会 RxJava 计划 #"></a>[3] 学会 RxJava 计划 #</h2><ol>
<li>理解异步操作，复习一遍 AsyncTask/Handler;</li>
<li>理解观察者模式，理解 RxJava 的观察者模式；</li>
<li>看 RxJava 的 API；</li>
<li>查看别人的项目 Demo；</li>
<li>模仿一个 Demo；</li>
<li>输出一篇学习笔记；</li>
</ol>
<h2 id="4-精华资料汇总"><a href="#4-精华资料汇总" class="headerlink" title="[4] 精华资料汇总 #"></a>[4] 精华资料汇总 #</h2><ul>
<li><a href="http://gank.io/post/560e15be2dca930e00da1083#toc_1" target="_blank" rel="external">给 Android 开发者的 RxJava 详解 作者：扔物线</a></li>
<li><a href="https://github.com/rengwuxian/RxJavaSamples" target="_blank" rel="external">RxJava 和 Retrofit 结合使用的几个最常见使用方式举例</a></li>
<li><a href="https://segmentfault.com/a/1190000004049490" target="_blank" rel="external">谜之RxJava（一）—— 最基本的观察者模式</a></li>
<li><a href="https://segmentfault.com/a/1190000004049841" target="_blank" rel="external">谜之RxJava（二）—— Magic Lift</a></li>
<li><a href="https://segmentfault.com/a/1190000004051191" target="_blank" rel="external">迷之RxJava（三）—— 线程切换</a></li>
<li><a href="https://segmentfault.com/a/1190000004077117" target="_blank" rel="external">迷之RxJava（四）—— Retrofit和RxJava的基情</a></li>
<li><a href="http://blog.csdn.net/pangpang123654/article/details/51535481" target="_blank" rel="external">观察者模式在Android开发场景中运用之通过Java源码分析(一)</a></li>
<li><a href="https://github.com/cn-ljb/rxjava_for_android" target="_blank" rel="external">Rxjava_for_android Demos</a></li>
</ul>
<p>Not End. 未完待续…</p>
<p>Note by <a href="http://isayes.github.io" target="_blank" rel="external">HF</a>.  </p>
<hr>

      
    </div>
    <footer>
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>
<!-- hackish -->

  
</div>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2017 HuFei
  
</div>
<div class="clearfix"></div></footer>
  <script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="http://apps.bdimg.com/libs/fancybox/2.1.5/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>