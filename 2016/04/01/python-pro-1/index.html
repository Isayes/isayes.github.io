<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title># Python 进阶&amp;1 函数式编程 | Notes.HF</title>
  <meta name="author" content="HuFei">
  
  <meta name="description" content="Notes of Daily Learning">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="# Python 进阶&amp;1 函数式编程"/>
  <meta property="og:site_name" content="Notes.HF"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Notes.HF" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
  
</head>

<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Notes.HF</a></h1>
  <h2><a href="/">notes of buaaGS1521AA9.hufei | 用来笔记一下</a></h2>
</div>
<nav id="main-nav">
  <ul>
    
      <li><a href="/more">分类</a></li>
    
      <li><a href="/works">作品</a></li>
    
      <li><a href="http://www.cnblogs.com/isayes">博客</a></li>
    
      <li><a href="http://weibo.com/khufly">微博</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
<div class="alignleft" style="margin-top: 15px">


  <iframe src="http://ghbtns.com/github-btn.html?user=Isayes&type=follow"
  allowtransparency="true" frameborder="0" scrolling="0" width="132" height="20"></iframe>

</div>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="wrapper"><article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
  
    <h1 class="title"># Python 进阶&amp;1 函数式编程</h1>
  

      
        <p class="published">
          Published: <time datetime="2016-04-01T00:58:29.000Z">2016-04-01</time>
        </p>
      
    </header>
    <div class="entry">
      
        <p>入门阶段的系列笔记传送门 → <a href="http://blog.csdn.net/Heartyhu/article/category/6147921" target="_blank" rel="external">进这里</a></p>
<p>接下来的学习目标：掌握函数式编程、如何使用 Python 的模块（内置模块和第三方模块）、面向对象编程（面向对象的概念、属性、方法、继承、多态等）、定制类（利用 Python 的特殊方法定制类）<br><a id="more"></a><br>核心学习目标：</p>
<ul>
<li>掌握函数式编程</li>
<li>掌握面向对象编程</li>
<li>能够编写模块化的程序</li>
</ul>
<h2 id="1-函数式编程"><a href="#1-函数式编程" class="headerlink" title="1. 函数式编程"></a>1. 函数式编程</h2><p>函数式（functional）是一种编程的范式。</p>
<p>[ 不同语言的抽象层次不同：]</p>
<pre><code>（高）        Python → 函数式       计算
  ↑        c语言    → 函数          ↑
  ↑          汇编语言                ↑
（低）        计算机硬件    → 指令    计算机
</code></pre><p>[ 函数式编程的特点：]</p>
<ul>
<li>把计算视为函数而非指令</li>
<li>纯函数式编程：不需要变量，没有副作用，测试简单</li>
<li>支持高阶函数，代码简洁</li>
</ul>
<p>[ Python 支持的函数式编程：]</p>
<ul>
<li>不是纯函数式编程：因为 Python 允许有变量</li>
<li>支持高阶函数：函数可以作为变量传入</li>
<li>支持闭包：有了闭包就能够返回函数</li>
<li>有限度地支持匿名函数</li>
</ul>
<h3 id="1-1-高阶函数"><a href="#1-1-高阶函数" class="headerlink" title="1-1. 高阶函数"></a>1-1. 高阶函数</h3><p>变量可以指向函数，函数名其实就是指向函数的变量。</p>
<ul>
<li>变量可以指向函数</li>
<li>函数的参数可以支持接收变量</li>
<li>一个函数可以接收另一个函数作为参数</li>
<li><p>能够接收函数作为参数的函数就是高阶函数</p>
<p>  def add(x,y,f):</p>
<pre><code>return f(x) + f(y)
</code></pre></li>
</ul>
<p>例如：add(-5,9,abs)</p>
<p>由于参数 x, y 和 f 都可以任意传入，如果 f 传入其他函数，就可以得到不同的返回值。比如：add(25, 9, math.sqrt)</p>
<p><strong>[ map() 函数：]</strong></p>
<p>map() 是 Python 内置的高阶函数，它接收<strong>一个函数 f 和一个 list</strong>，并通过把函数 f 依次作用在 list 的每个元素上，得到一个新的 list 并返回。</p>
<p>例如，对于 list [1, 2, 3, 4, 5, 6, 7, 8, 9]，如果希望把 list 的每个元素都作平方，就可以用 map() 函数：</p>
<p><img src="http://img.mukewang.com/54c8a7e40001327303410245.png" alt=""></p>
<p>因此，我们只需要传入函数 f(x)=x*x，就可以利用 map() 函数完成这个计算：</p>
<pre><code>def f(x):
    return x*x
print map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])
</code></pre><p>输出结果：[1, 4, 9, 10, 25, 36, 49, 64, 81]</p>
<p>注意：map() 函数不改变原有的 list，而是返回一个新的 list。</p>
<p>利用 map() 函数，可以把一个 list 转换为另一个 list，只需要传入转换函数。</p>
<p>由于 list 包含的元素可以是任何类型，因此，map() 不仅仅可以处理只包含数值的 list，事实上它可以处理包含任意类型的 list，只要传入的函数 f 可以处理这种数据类型。</p>
<p>例子：假设用户输入的英文名字不规范，没有按照首字母大写，后续字母小写的规则，利用 map() 函数，把一个 list（包含若干不规范的英文名字）变成一个包含规范英文名字的 list</p>
<pre><code>def format_name(s):
    return s[0].upper() + s[1:].lower()

print map(format_name, [&apos;adam&apos;, &apos;LISA&apos;, &apos;barT&apos;])
</code></pre><p><strong>[ reduce() 函数：]</strong></p>
<p>reduce() 函数也是 Python 内置的一个高阶函数。reduce() 函数接收的参数和 map() 类似，一个函数 f，一个 list，但行为和 map() 不同，reduce() 传入的函数 f 必须接收两个参数，reduce() 对 list 的每个元素反复调用函数 f，并返回最终结果值。</p>
<p>例如，编写一个 f 函数，接收 x 和 y，返回 x 和 y 的和：</p>
<pre><code>def f(x, y):
    return x + y
</code></pre><p>调用 <code>reduce(f, [1, 3, 5, 7, 9])</code> 时，reduce 函数将做如下计算：</p>
<ul>
<li>先计算头两个元素：f(1, 3)，结果为 4；</li>
<li>再把结果和第3个元素计算：f(4, 5)，结果为 9；</li>
<li>再把结果和第4个元素计算：f(9, 7)，结果为 16；</li>
<li>再把结果和第5个元素计算：f(16, 9)，结果为 25；</li>
<li>由于没有更多的元素了，计算结束，返回结果 25。</li>
</ul>
<p>上述计算实际上是对 list 的所有元素求和。虽然 Python 内置了求和函数 sum()，但是，利用 reduce() 求和也很简单。</p>
<p><strong>reduce() 还可以接收第3个可选参数，作为计算的初始值</strong>。如果把初始值设为100，计算：</p>
<p>reduce(f, [1, 3, 5, 7, 9], 100)<br>结果将变为 125，因为第一轮计算是：</p>
<p>计算初始值和第一个元素：f(100, 1)，结果为 101。</p>
<p>例子：Python内置了求和函数sum()，但没有求积的函数，请利用recude()来求积</p>
<pre><code>def prod(x, y):
    return x*y

print reduce(prod, [2, 4, 5, 7, 12])
</code></pre><p><strong>[ filter()函数：]</strong></p>
<p>filter() 函数是 Python 内置的另一个有用的高阶函数，filter() 函数接收一个函数 f 和一个 list，这个函数 f 的作用是对每个元素进行判断，返回 True 或 False，filter() 根据判断结果自动过滤掉不符合条件的元素，返回由符合条件元素组成的新 list。</p>
<p>例如，要从一个 list [1, 4, 6, 7, 9, 12, 17] 中删除偶数，保留奇数，首先，要编写一个判断奇数的函数：</p>
<pre><code>def is_odd(x):
    return x % 2 == 1
</code></pre><p>然后，利用 filter() 过滤掉偶数：</p>
<pre><code>filter(is_odd, [1, 4, 6, 7, 9, 12, 17])
# 结果：[1, 7, 9, 17]
</code></pre><p>利用 filter()，可以完成很多有用的功能，例如，删除 None 或者空字符串：</p>
<pre><code>def is_not_empty(s):
    return s and len(s.strip()) &gt; 0
filter(is_not_empty, [&apos;test&apos;, None, &apos;&apos;, &apos;str&apos;, &apos;  &apos;, &apos;END&apos;])
# 结果：[&apos;test&apos;, &apos;str&apos;, &apos;END&apos;]
</code></pre><p>注意: <strong>s.strip(rm)</strong> 删除 s 字符串中开头、结尾处的 rm 序列的字符。当 rm 为空时，默认删除空白符（包括’\n’, ‘\r’, ‘\t’, ‘ ‘)，如下：</p>
<pre><code>a = &apos;     123&apos;
a.strip()
# 结果：&apos;123&apos;

a=&apos;\t\t123\r\n&apos;
a.strip()
# 结果：&apos;123&apos;
</code></pre><p>例子：请利用 filter() 过滤出1~100中平方根是整数的数，即结果应该是 [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</p>
<pre><code>import math

def is_sqr(x):
    r = int(math.sqrt(x))
    return r*r == x

print filter(is_sqr, range(1, 101))
</code></pre><p><strong>[ 自定义排序函数：]</strong></p>
<p>Python 内置的 sorted() 函数可对 list 进行排序：</p>
<pre><code>&gt;&gt;&gt; sorted([36, 5, 12, 9, 21])
[5, 9, 12, 21, 36]
</code></pre><p>但 sorted() 也是一个高阶函数，它可以接收一个比较函数来实现自定义排序，比较函数的定义是，传入两个待比较的元素 x, y，如果 x 应该排在 y 的前面，返回 -1，如果 x 应该排在 y 的后面，返回 1。如果 x 和 y 相等，返回 0。(-1 换，1 不换)</p>
<p>因此，如果我们要实现倒序排序，只需要编写一个 reversed_cmp 函数：</p>
<pre><code>def reversed_cmp(x, y):
    if x &gt; y:
        return -1
    if x &lt; y:
        return 1
    return 0
</code></pre><p>这样，调用 sorted() 并传入 reversed_cmp 就可以实现倒序排序：</p>
<pre><code>&gt;&gt;&gt; sorted([36, 5, 12, 9, 21], reversed_cmp)
[36, 21, 12, 9, 5]
</code></pre><p>sorted() 也可以对字符串进行排序，字符串默认按照 ASCII 大小来比较：</p>
<pre><code>&gt;&gt;&gt; sorted([&apos;bob&apos;, &apos;about&apos;, &apos;Zoo&apos;, &apos;Credit&apos;])
[&apos;Credit&apos;, &apos;Zoo&apos;, &apos;about&apos;, &apos;bob&apos;]
</code></pre><p>‘Zoo’ 排在 ‘about’ 之前是因为 ‘Z’ 的 ASCII 码比 ‘a’ 小。</p>
<p>例子：对字符串排序时，有时候忽略大小写排序更符合习惯。利用 sorted() 高阶函数，实现忽略大小写排序的算法</p>
<pre><code>def cmp_ignore_case(s1, s2):
    s1 = s1.lower()
    s2 = s2.lower()
    if s1 &lt; s2:
        return -1
    if s1 &gt; s2:
        return 1
    return 0

print sorted([&apos;bob&apos;, &apos;about&apos;, &apos;Zoo&apos;, &apos;Credit&apos;], cmp_ignore_case)
</code></pre><p><strong>[ 返回函数：]</strong></p>
<p>Python 的函数不但可以返回 int、str、list、dict 等数据类型，还可以返回函数！</p>
<p>例如，定义一个函数 f()，我们让它返回一个函数 g，可以这样写：</p>
<pre><code>def f():
    print &apos;call f()...&apos;

    # 定义函数g:
    def g():
        print &apos;call g()...&apos;

    # 返回函数g:
    return g
</code></pre><p>仔细观察上面的函数定义，我们在函数 f 内部又定义了一个函数 g。由于函数 g 也是一个对象，函数名 g 就是指向函数 g 的变量，所以，最外层函数 f 可以返回变量 g，也就是函数 g 本身。</p>
<p>调用函数 f，我们会得到 f 返回的一个函数：</p>
<pre><code>&gt;&gt;&gt; x = f()   # 调用f()
call f()...
&gt;&gt;&gt; x   # 变量x是f()返回的函数：
&lt;function g at 0x1037bf320&gt;
&gt;&gt;&gt; x()   # x指向函数，因此可以调用
call g()...   # 调用x()就是执行g()函数定义的代码
</code></pre><p>请注意区分返回函数和返回值：</p>
<pre><code>def myabs():
    return abs   # 返回函数

def myabs2(x):
    return abs(x)   # 返回函数调用的结果，返回值是一个数值
</code></pre><p>返回函数可以把一些计算延迟执行。例如，如果定义一个普通的求和函数：</p>
<pre><code>def calc_sum(lst):
    return sum(lst)
</code></pre><p>调用calc_sum()函数时，将立刻计算并得到结果：</p>
<pre><code>&gt;&gt;&gt; calc_sum([1, 2, 3, 4])
10
</code></pre><p>但是，如果返回一个函数，就可以“延迟计算”：</p>
<pre><code>def calc_sum(lst):
    def lazy_sum():
        return sum(lst)
    return lazy_sum
</code></pre><p>调用 calc_sum() 并没有计算出结果，而是返回函数:</p>
<pre><code>&gt;&gt;&gt; f = calc_sum([1, 2, 3, 4])
&gt;&gt;&gt; f
&lt;function lazy_sum at 0x1037bfaa0&gt;
</code></pre><p>对返回的函数进行调用时，才计算出结果:</p>
<pre><code>&gt;&gt;&gt; f()
10
</code></pre><p>由于可以返回函数，我们在后续代码里就可以决定到底要不要调用该函数。</p>
<p>例子：编写一个函数 calc_prod(lst)，它接收一个 list，返回一个函数，返回函数可以计算参数的乘积</p>
<pre><code>def calc_prod(lst):
    def g():
        def f(x, y):
            return x * y
        return reduce(f,lst,1)
    return g

f = calc_prod([1, 2, 3, 4])
print f()
</code></pre><p><strong>[ 闭包：]</strong></p>
<p>在函数内部定义的函数和外部定义的函数是一样的，只是他们无法被外部访问：</p>
<pre><code>def g():
    print &apos;g()...&apos;

def f():
    print &apos;f()...&apos;
    return g
</code></pre><p>将 g 的定义移入函数 f 内部，防止其他代码调用 g：</p>
<pre><code>def f():
    print &apos;f()...&apos;
    def g():
        print &apos;g()...&apos;
    return g
</code></pre><p>但是，考察上一小节定义的 calc_sum 函数：</p>
<pre><code>def calc_sum(lst):
    def lazy_sum():
        return sum(lst)
    return lazy_sum
</code></pre><p>注意: 发现没法把 lazy_sum 移到 calc_sum 的外部，因为它引用了 calc_sum 的参数 lst。</p>
<p><strong>像这种内层函数引用了外层函数的变量（参数也算变量），然后返回内层函数的情况，称为闭包（Closure）</strong>。</p>
<p>闭包的特点是返回的函数还引用了外层函数的局部变量，所以，要正确使用闭包，就要确保引用的局部变量在函数返回后不能变。举例如下：</p>
<pre><code># 希望一次返回3个函数，分别计算1x1,2x2,3x3:
def count():
    fs = []
    for i in range(1, 4):
        def f():
             return i*i
        fs.append(f)
    return fs

f1, f2, f3 = count()
</code></pre><p><em>原认为调用 f1()，f2() 和 f3()结果应该是 1，4，9，但实际结果全部都是 9</em>。</p>
<p>原因就是当 count() 函数返回了3个函数时，这 3个函数所引用的变量 i 的值已经变成了 3。由于 f1、f2、f3 并没有被调用，所以，此时他们并未计算 i*i，当 f1 被调用时：</p>
<pre><code>&gt;&gt;&gt; f1()
9     # 因为 f1 现在才计算 i*i，但现在 i 的值已经变为 3
</code></pre><p>因此，返回函数不要引用任何循环变量，或者后续会发生变化的变量。</p>
<p><strong>例子：</strong> 返回闭包不能引用循环变量，请改写 count() 函数，让它正确返回能计算 1x1、2x2、3x3 的函数。</p>
<p>考察下面的函数 f:</p>
<pre><code>def f(j):
    def g():
        return j*j
    return g
</code></pre><p>它可以正确地返回一个闭包 g，g 所引用的变量 j 不是循环变量，因此将正常执行。</p>
<p>在 count 函数的循环内部，如果借助f函数，就可以避免引用循环变量 i。</p>
<p>答案：</p>
<pre><code>def count():
    fs = []
    for i in range(1, 4):
        def f(j):
            def g():
                return j*j
            return g
        r = f(i)
        fs.append(r)
    return fs

f1, f2, f3 = count()
print f1(), f2(), f3()
</code></pre><p><strong>[ 匿名函数：]</strong></p>
<p>高阶函数可以接收函数做参数，有些时候，我们不需要显式地定义函数，直接传入匿名函数更方便。</p>
<p>在 Python中，对匿名函数提供了有限支持。还是以 map() 函数为例，计算 f(x)=x2 时，除了定义一个 f(x) 的函数外，还可以直接传入匿名函数：</p>
<pre><code>&gt;&gt;&gt; map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9])
[1, 4, 9, 16, 25, 36, 49, 64, 81]
</code></pre><p>通过对比可以看出，匿名函数 lambda x: x * x 实际上就是：</p>
<pre><code>def f(x):
    return x * x
</code></pre><p>关键字 <strong>lambda</strong> 表示匿名函数，冒号前面的 x 表示函数参数。</p>
<p>匿名函数有个限制，就是只能有一个表达式，不写 return，返回值就是该表达式的结果。</p>
<p>使用匿名函数，可以不必定义函数名，直接创建一个函数对象，很多时候可以简化代码：</p>
<pre><code>&gt;&gt;&gt; sorted([1, 3, 9, 5, 0], lambda x,y: -cmp(x,y))
[9, 5, 3, 1, 0]
</code></pre><p>返回函数的时候，也可以返回匿名函数：</p>
<pre><code>&gt;&gt;&gt; myabs = lambda x: -x if x &lt; 0 else x 
&gt;&gt;&gt; myabs(-1)
1
&gt;&gt;&gt; myabs(1)
1
</code></pre><p>例子：利用匿名函数简化以下代码：</p>
<pre><code>def is_not_empty(s):
    return s and len(s.strip()) &gt; 0
filter(is_not_empty, [&apos;test&apos;, None, &apos;&apos;, &apos;str&apos;, &apos;  &apos;, &apos;END&apos;])
</code></pre><p>答案：</p>
<pre><code>def is_not_empty(s):
    return s and len(s.strip()) &gt; 0

print filter(lambda s : s and len(s.strip()) &gt; 0, [&apos;test&apos;, None, &apos;&apos;, &apos;str&apos;, &apos;  &apos;, &apos;END&apos;])
</code></pre><h3 id="1-2-decorator-装饰器"><a href="#1-2-decorator-装饰器" class="headerlink" title="1-2. decorator 装饰器"></a>1-2. decorator 装饰器</h3><p>问题：</p>
<ul>
<li>定义了一个函数</li>
<li>想在运行时动态增加功能</li>
<li>又不想改动函数本身的代码</li>
</ul>
<p>示例：</p>
<p>希望对下列函数调用增加 log 功能，打印函数调用：</p>
<pre><code>def f1(x):
    return x*2
def f2():
    return x*x
def f3():
    return x*x*x
</code></pre><p>方法 1：直接修改原函数</p>
<pre><code>def f1(x):
    print &apos;call f1()&apos;
    return x*2
def f2():
    print &apos;call f2()&apos;
    return x*x
def f3():
    print &apos;call f3()&apos;
    return x*x*x
</code></pre><p>有没有更简单的方法呢？</p>
<p>回顾一下高阶函数：</p>
<ul>
<li>可以接收函数作为参数</li>
<li>可以返回函数</li>
</ul>
<p>是否可以接收一个函数，对其包装，然后返回一个函数？</p>
<p>方法 2：通过高阶函数返回新函数</p>
<pre><code>def f1(x):
    return x*2

def new_fn(f):  # 装饰器函数
    def fn(x):
        print &apos;call&apos; + f._name_ + &apos;()&apos;
        return f(x)
    return fn    
</code></pre><p>g1 = new_fn(f1)<br>print g1(5)</p>
<p>f1 = new_fn(f1)<br>print f1(5)</p>
<p>f1 的原始定义函数被彻底隐藏了，利用 f1 只能拿到装饰以后的函数</p>
<p><strong>[ 装饰器：]</strong></p>
<p>Python 内置的 @ 语法就是为了简化装饰器调用</p>
<pre><code>@new_fn
def f1(x):
    return x*2
</code></pre><p>==&gt;</p>
<pre><code>def f1(x):
    return x*2
f1 = new_fn(f1)
</code></pre><p><strong>[ 装饰器的作用：]</strong></p>
<p>可以极大地简化代码，避免每个函数编写重复性代码</p>
<ul>
<li>打印日志：@log</li>
<li>检测性能：@performance</li>
<li>数据库事务：@transaction</li>
<li>URL路由：@post(‘/register’)</li>
</ul>
<p><strong>[ 编写无参数 decorator：]</strong></p>
<p>Python的 decorator 本质上就是一个高阶函数，它接收一个函数作为参数，然后，返回一个新函数。</p>
<p>使用 decorator 用 Python 提供的 @ 语法，这样可以避免手动编写 f = decorate(f) 这样的代码。</p>
<p>考察一个 @log 的定义：</p>
<pre><code>def log(f):
    def fn(x):
        print &apos;call &apos; + f.__name__ + &apos;()...&apos;
        return f(x)
    return fn
</code></pre><p>对于阶乘函数，@log 工作得很好：</p>
<pre><code>@log
def factorial(n):
    return reduce(lambda x,y: x*y, range(1, n+1))
print factorial(10)
</code></pre><p>结果：<br>call factorial()…<br>3628800</p>
<p>但是，对于参数不是一个的函数，调用将报错：</p>
<pre><code>@log
def add(x, y):
    return x + y
print add(1, 2)
</code></pre><p>结果：</p>
<pre><code>Traceback (most recent call last):
  File &quot;test.py&quot;, line 15, in &lt;module&gt;
    print add(1,2)
TypeError: fn() takes exactly 1 argument (2 given)
</code></pre><p>因为 add() 函数需要传入两个参数，但是 @log 写死了只含一个参数的返回函数。</p>
<p>要让 @log 自适应任何参数定义的函数，可以利用 Python 的 <code>*args</code> 和 <code>**kw</code>，保证任意个数的参数总是能正常调用：</p>
<pre><code>def log(f):
    def fn(*args, **kw):
        print &apos;call &apos; + f.__name__ + &apos;()...&apos;
        return f(*args, **kw)
    return fn
</code></pre><p>现在，对于任意函数，@log 都能正常工作。</p>
<p>例子：编写一个 @performance ，它可以打印出函数调用的时间。</p>
<p>答案：</p>
<pre><code>import time

def performance(f):
    def fn(*args, **kw):
        t1 = time.time()
        r = f(*args, **kw)
        t2 = time.time()
        print &apos;call %s() in %fs&apos; % (f.__name__, (t2 - t1))
        return r
    return fn

@performance
def factorial(n):
    return reduce(lambda x,y: x*y, range(1, n+1))

print factorial(10)
</code></pre><p><strong>[ 编写带参数 decorator：]</strong></p>
<p>考察上一节的 @log 装饰器：</p>
<pre><code>def log(f):
    def fn(x):
        print &apos;call &apos; + f.__name__ + &apos;()...&apos;
        return f(x)
    return fn
</code></pre><p>发现对于被装饰的函数，log 打印的语句是不能变的（除了函数名）。</p>
<p>如果有的函数非常重要，希望打印出 ‘[INFO] call xxx()…’，有的函数不太重要，希望打印出 ‘[DEBUG] call xxx()…’，这时，log 函数本身就需要传入 ‘INFO’ 或 ‘DEBUG’ 这样的参数，类似这样：</p>
<pre><code>@log(&apos;DEBUG&apos;)
def my_func():
    pass
</code></pre><p>把上面的定义翻译成高阶函数的调用，就是：</p>
<pre><code>my_func = log(&apos;DEBUG&apos;)(my_func)
</code></pre><p>上面的语句看上去还是比较绕，再展开一下：</p>
<pre><code>log_decorator = log(&apos;DEBUG&apos;)
my_func = log_decorator(my_func)
</code></pre><p>上面的语句又相当于：</p>
<pre><code>log_decorator = log(&apos;DEBUG&apos;)
@log_decorator
def my_func():
    pass
</code></pre><p>所以，带参数的 log 函数首先返回一个 decorator 函数，再让这个 decorator 函数接收 my_func 并返回新函数：</p>
<pre><code>def log(prefix):
    def log_decorator(f):
        def wrapper(*args, **kw):
            print &apos;[%s] %s()...&apos; % (prefix, f.__name__)
            return f(*args, **kw)
        return wrapper
    return log_decorator

@log(&apos;DEBUG&apos;)
def test():
    pass
print test()
</code></pre><p>执行结果：</p>
<p>[DEBUG] test()…<br>None<br>对于这种3层嵌套的 decorator 定义，你可以先把它拆开：</p>
<pre><code># 标准decorator:
def log_decorator(f):
    def wrapper(*args, **kw):
        print &apos;[%s] %s()...&apos; % (prefix, f.__name__)
        return f(*args, **kw)
    return wrapper
return log_decorator

# 返回decorator:
def log(prefix):
    return log_decorator(f)
</code></pre><p>拆开以后会发现，调用会失败，因为在 3 层嵌套的 decorator 定义中，最内层的 wrapper 引用了最外层的参数 prefix，所以，把一个闭包拆成普通的函数调用会比较困难。不支持闭包的编程语言要实现同样的功能就需要更多的代码。</p>
<p>例子：前面例子的 @performance 只能打印秒，给 @performace 增加一个参数，允许传入’s’或’ms’</p>
<pre><code>@performance(&apos;ms&apos;)
def factorial(n):
    return reduce(lambda x,y: x*y, range(1, n+1))
</code></pre><p>答案：</p>
<pre><code>import time

def performance(unit):
    def perf_decorator(f):
        def wrapper(*args, **kw):
            t1 = time.time()
            r = f(*args, **kw)
            t2 = time.time()
            t = (t2 - t1) * 1000 if unit == &apos;ms&apos; else (t2 - t1)
            print &apos;call %s() in %f %s&apos; % (f.__name__, t, unit)
            return r
        return wrapper

    return perf_decorator

@performance(&apos;ms&apos;)
def factorial(n):
    return reduce(lambda x,y: x*y, range(1, n+1))

print factorial(10)

# 结果： call factorial() in 7.776022 ms 3628800
</code></pre><p><strong>[ 完善decorator：]</strong></p>
<p>@decorator 可以动态实现函数功能的增加，但是，经过 @decorator “改造” 后的函数，和原函数相比，除了功能多一点外，有没有其它不同的地方？</p>
<p>在没有 decorator 的情况下，打印函数名：</p>
<pre><code>def f1(x):
    pass
print f1.__name__
# 输出： f1
</code></pre><p>有decorator的情况下，再打印函数名：</p>
<pre><code>def log(f):
    def wrapper(*args, **kw):
        print &apos;call...&apos;
        return f(*args, **kw)
    return wrapper
@log
def f2(x):
    pass
print f2.__name__
# 输出： wrapper
</code></pre><p>可见，由于 decorator 返回的新函数函数名已经不是 ‘f2’，而是 @log 内部定义的 ‘wrapper’。这对于那些依赖函数名的代码就会失效。decorator 还改变了函数的 <strong>doc</strong> 等其它属性。如果要让调用者看不出一个函数经过了 @decorator 的 “改造”，就需要把原函数的一些属性复制到新函数中：</p>
<pre><code>def log(f):
    def wrapper(*args, **kw):
        print &apos;call...&apos;
        return f(*args, **kw)
    wrapper.__name__ = f.__name__
    wrapper.__doc__ = f.__doc__
    return wrapper
</code></pre><p>这样写 decorator 很不方便，因为我们也很难把原函数的所有必要属性都一个一个复制到新函数上，所以 Python 内置的 functools 可以用来自动化完成这个 “复制” 的任务：</p>
<pre><code>import functools
def log(f):
    @functools.wraps(f)
    def wrapper(*args, **kw):
        print &apos;call...&apos;
        return f(*args, **kw)
    return wrapper
</code></pre><p>最后需要指出，由于我们把原函数签名改成了<code>(*args, **kw)</code>，因此，无法获得原函数的原始参数信息。即便我们采用固定参数来装饰只有一个参数的函数：</p>
<pre><code>def log(f):
    @functools.wraps(f)
    def wrapper(x):
        print &apos;call...&apos;
        return f(x)
    return wrapper
</code></pre><p>也可能改变原函数的参数名，因为新函数的参数名始终是 ‘x’，原函数定义的参数名不一定叫 ‘x’。</p>
<p>例子：</p>
<pre><code>import time, functools

def performance(unit):
    def perf_decorator(f):
        @functools.wraps(f)
        def wrapper(*args, **kw):
            t1 = time.time()
            r = f(* args, **kw)
            t2 = time.time()
            t = (t2 - t1) * 1000 if unit == &apos;ms&apos; else (t2-t1)
            print &apos;call %s() in %f %s&apos; % (f.__name__,t,unit)
            return r

        return wrapper

    return perf_decorator

@performance(&apos;ms&apos;)
def factorial(n):
    return reduce(lambda x,y: x*y, range(1, n+1))

print factorial.__name__

# 输出：factorial
</code></pre><h3 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h3><p>当一个函数有很多参数时，调用者就需要提供多个参数。如果减少参数个数，就可以简化调用者的负担。</p>
<p>比如，int() 函数可以把字符串转换为整数，当仅传入字符串时，int() 函数默认按十进制转换：</p>
<pre><code>&gt;&gt;&gt; int(&apos;12345&apos;)
12345
</code></pre><p>但 int() 函数还提供额外的 base 参数，默认值为 10。如果传入 base 参数，就可以做 N 进制的转换：</p>
<pre><code>&gt;&gt;&gt; int(&apos;12345&apos;, base=8)
5349
&gt;&gt;&gt; int(&apos;12345&apos;, 16)
74565
</code></pre><p>假设要转换大量的二进制字符串，每次都传入 int(x, base=2) 非常麻烦，于是，我们想到，可以定义一个 int2() 的函数，默认把 base=2 传进去：</p>
<pre><code>def int2(x, base=2):
    return int(x, base)
</code></pre><p>这样，我们转换二进制就非常方便了：</p>
<pre><code>&gt;&gt;&gt; int2(&apos;1000000&apos;)
64
&gt;&gt;&gt; int2(&apos;1010101&apos;)
85
</code></pre><p>functools.partial 就是帮助我们创建一个偏函数的，不需要我们自己定义 int2()，可以直接使用下面的代码创建一个新的函数 int2：</p>
<pre><code>&gt;&gt;&gt; import functools
&gt;&gt;&gt; int2 = functools.partial(int, base=2)
&gt;&gt;&gt; int2(&apos;1000000&apos;)
64
&gt;&gt;&gt; int2(&apos;1010101&apos;)
85
</code></pre><p>所以，functools.partial 可以把一个参数多的函数变成一个参数少的新函数，少的参数需要在创建时指定默认值，这样，新函数调用的难度就降低了。</p>
<p>例子：<br>我们在 sorted 这个高阶函数中传入自定义排序函数就可以实现忽略大小写排序。请用 functools.partial 把这个复杂调用变成一个简单的函数：<code>sorted_ignore_case(iterable)</code></p>
<p>答：<br>要固定 sorted() 的 cmp 参数，需要传入一个排序函数作为cmp的默认值。</p>
<pre><code>import functools

sorted_ignore_case = functools.partial(sorted, cmp = lambda s1, s2 : cmp(s1.upper(), s2.upper()))
print sorted_ignore_case([&apos;bob&apos;, &apos;about&apos;, &apos;Zoo&apos;, &apos;Credit&apos;])
</code></pre><p>Note by <a href="http://isayes.github.io" target="_blank" rel="external">HF</a>.  </p>
<hr>

      
    </div>
    <footer>
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>
<!-- hackish -->

  
</div>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2017 HuFei
  
</div>
<div class="clearfix"></div></footer>
  <script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="http://apps.bdimg.com/libs/fancybox/2.1.5/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>