<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title># Unity 自学与进阶必会目录 | Notes.HF</title>
  <meta name="author" content="HuFei">
  
  <meta name="description" content="Notes of Daily Learning">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="# Unity 自学与进阶必会目录"/>
  <meta property="og:site_name" content="Notes.HF"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Notes.HF" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
  
</head>

<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Notes.HF</a></h1>
  <h2><a href="/">notes of buaaGS1521AA9.hufei | 用来笔记一下</a></h2>
</div>
<nav id="main-nav">
  <ul>
    
      <li><a href="/more">分类</a></li>
    
      <li><a href="/works">作品</a></li>
    
      <li><a href="http://blog.csdn.net/heartyhu">博客</a></li>
    
      <li><a href="http://weibo.com/khufly">微博</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
<div class="alignleft" style="margin-top: 15px">


  <iframe src="http://ghbtns.com/github-btn.html?user=Isayes&type=follow"
  allowtransparency="true" frameborder="0" scrolling="0" width="132" height="20"></iframe>

</div>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="wrapper"><article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
  
    <h1 class="title"># Unity 自学与进阶必会目录</h1>
  

      
        <p class="published">
          Published: <time datetime="2016-12-19T05:36:11.000Z">2016-12-19</time>
        </p>
      
    </header>
    <div class="entry">
      
        <p>六本书</p>
<ol>
<li>Unity 5权威讲解</li>
<li>Unity 3D NGUI 实战教程</li>
<li>Unity 5实战 使用C和Unity开发多平台游戏</li>
<li>Unity 3D人工智能编程</li>
<li>Unity官方案例精讲</li>
<li>Unity Shader入门精要</li>
</ol>
<a id="more"></a>
<h2 id="1-Unity-5权威讲解"><a href="#1-Unity-5权威讲解" class="headerlink" title="1. Unity 5权威讲解 #"></a>1. Unity 5权威讲解 #</h2><p>目录</p>
<ul>
<li>第1章　Unity 5简介　1</li>
<li>1.1　Unity 3D游戏引擎的诞生　2</li>
<li>1.2　Unity 5的优势　2</li>
<li>1.2.1　支持多平台　2</li>
<li>1.2.2　集成开发环境　3</li>
<li>1.2.3　所有功能免费　4</li>
<li>1.2.4　中间件内建　5</li>
<li>1.2.5　开放社区　5</li>
<li>1.2.6　资源商店　6</li>
<li>1.3　使用Unity制作的游戏　7</li>
<li>1.4　下载Unity　9</li>
<li>1.4.1　安装Unity　10</li>
<li>1.4.2　选择Unity许可　11</li>
<li>1.4.3　注册并登录Unity　12</li>
<li>1.5　Unity界面　13</li>
<li>1.5.1　视图　16</li>
<li>1.5.2　工具栏　27</li>
<li>1.5.3　设置快捷键　34</li>
<li>1.6　小结　34</li>
<li>第2章　准备游戏开发　35</li>
<li>2.1　开发的游戏以及开发顺序　36</li>
<li>2.2　新建项目　36</li>
<li>2.3　设置Unity IDE　37</li>
<li>2.4　系统管理项目视图　39</li>
<li>2.5　导入角色模型　39</li>
<li>2.6　创建资源商店账号　42</li>
<li>2.7　从项目视图访问资源商店　44</li>
<li>2.8　从资源商店下载资源　45</li>
<li>2.9　小结　48</li>
<li>第3章　制作游戏场景　49</li>
<li>3.1　3D模型　50</li>
<li>3.2　纹理　51</li>
<li>3.3　材质　53</li>
<li>3.4　应用纹理　54</li>
<li>3.5　着色器以及基于物理的着色　58</li>
<li>3.5.1　渲染模式　59</li>
<li>3.5.2　反照率　59</li>
<li>3.5.3　金属　59</li>
<li>3.5.4　法线贴图　59</li>
<li>3.5.5　高度图　60</li>
<li>3.5.6　遮挡贴图　60</li>
<li>3.5.7　放射　61</li>
<li>3.5.8　细节遮蔽　61</li>
<li>3.6　表现地面阴影——使用法线贴图　61</li>
<li>3.7　预设　62</li>
<li>3.8　用预设制作墙体　64</li>
<li>3.9　光照　68</li>
<li>3.9.1　平行光　68</li>
<li>3.9.2　点光源　69</li>
<li>3.9.3　聚光灯　69</li>
<li>3.9.4　区域光　70</li>
<li>3.10　天空的表现方法　71</li>
<li>3.10.1　六面天空盒　72</li>
<li>3.10.2　程序天空盒　74</li>
<li>3.10.3　立方图天空盒　76</li>
<li>3.11　小结　76</li>
<li>第4章　制作主人公角色　77</li>
<li>4.1　空游戏对象　78</li>
<li>4.2　导入3D模型并设置选项　79</li>
<li>4.3　组件　80</li>
<li>4.4　生成脚本　81</li>
<li>4.5　下载键盘输入值　84</li>
<li>4.6　角色移动　87</li>
<li>4.6.1　处理组件缓存　88</li>
<li>4.6.2　游戏对象的移动　89</li>
<li>4.6.3　Translate函数　90</li>
<li>4.7　单位向量　91</li>
<li>4.8　角色旋转：Rotate　94</li>
<li>4.9　摄像机追踪：Follow Cam　95</li>
<li>4.10　Legacy动画系统　98</li>
<li>4.11　动画片段　99</li>
<li>4.12　动画控件　104</li>
<li>4.13　动画合成　107</li>
<li>4.14　实时阴影　108</li>
<li>4.15　运用投影器制作阴影　111</li>
<li>4.16　运用平面网格制作阴影　115</li>
<li>4.17　小结　117</li>
<li>第5章　制作子弹发射效果　119</li>
<li>5.1　准备子弹模型　120</li>
<li>5.2　Rigidbody组件　121</li>
<li>5.3　设置物理引擎属性：Physics Manager　124</li>
<li>5.4　Collider组件　125</li>
<li>5.4.1　Box Collider　125</li>
<li>5.4.2　Sphere Collider　125</li>
<li>5.4.3　Capsule Collider　126</li>
<li>5.4.4　Mesh Collider　126</li>
<li>5.4.5　Wheel Collider　127</li>
<li>5.4.6　Terrain Collider　128</li>
<li>5.5　碰撞感知条件　128</li>
<li>5.6　碰撞事件　130</li>
<li>5.7　Tag应用　132</li>
<li>5.8　子弹发射逻辑　135</li>
<li>5.9　制作子弹发射轨迹：Trail Renderer　140</li>
<li>5.10　应用粒子系统　145</li>
<li>5.11　制作爆炸效果并设置爆炸威力　150</li>
<li>5.12　随机使用纹理　155</li>
<li>5.13　声音：AudioSource与AudioListener　157</li>
<li>5.14　枪口火焰效果：Muzzle Flash　164</li>
<li>5.15　小结　170</li>
<li>第6章　制作敌对角色　171</li>
<li>6.1　Mecanim动画系统　172</li>
<li>6.2　导入怪兽3D模型　173</li>
<li>6.3　转换为Mecanim动画　173</li>
<li>6.4　动画控制器　177</li>
<li>6.5　导航：怪兽追击例程　183</li>
<li>6.5.1　生成导航网格并烘焙　184</li>
<li>6.5.2　Nav Mesh Agent　185</li>
<li>6.6　实现人工智能　188</li>
<li>6.7　怪兽攻击例程　197</li>
<li>6.8　怪兽被袭时的反应　199</li>
<li>6.9　血迹效果　203</li>
<li>6.10　贴图：地面上的血迹效果　206</li>
<li>6.11　赋予怪兽攻击技能　211</li>
<li>6.12　特定层之间的碰撞感知　215</li>
<li>6.13　优化Mecanim动画角色的骨骼结构　218</li>
<li>6.14　怪兽停止攻击：Tag　220</li>
<li>6.15　怪兽停止攻击：Delegate、Event　224</li>
<li>6.16　怪兽的死亡处理　228</li>
<li>6.17　小结　235</li>
<li>第7章　Unity UI　237</li>
<li>7.1　Canvas对象　238</li>
<li>7.1.1　EventSystem对象　239</li>
<li>7.1.2　Canvas组件　240</li>
<li>7.2　Rect Transform组件　244</li>
<li>7.3　anchoredPosition属性　252</li>
<li>7.4　Image组件　254</li>
<li>7.4.1　Simple　256</li>
<li>7.4.2　Sliced　256</li>
<li>7.4.3　Tiled　258</li>
<li>7.4.4　Filed　258</li>
<li>7.5　RawImage 组件　259</li>
<li>7.6　Button组件　260</li>
<li>7.7　Text组件　271</li>
<li>7.8　Scroll Rect组件　272</li>
<li>7.8.1　Content属性　275</li>
<li>7.8.2　Mask组件　276</li>
<li>7.9　制作游戏分数UI　277</li>
<li>7.10　制作生命条　285</li>
<li>7.11　小结　289</li>
<li>第8章　游戏管理器　291</li>
<li>8.1　怪兽出现逻辑　292</li>
<li>8.2　访问游戏管理器　296</li>
<li>8.3　单例模式　298</li>
<li>8.4　对象池　300</li>
<li>8.5　共享函数：声音处理　308</li>
<li>8.6　小结　311</li>
<li>第９章　灵活运用射线投射　313</li>
<li>9.1　射线投射　314</li>
<li>9.2　油桶爆炸　319</li>
<li>9.3　实现激光束　322</li>
<li>第10章　导航仪高级技巧　329</li>
<li>10.1　动态障碍物　330</li>
<li>10.2　分离网格链接　333</li>
<li>10.3　用户自定义生成分离网格链接　335</li>
<li>第11章　光照贴图、灯光探测器　337</li>
<li>11.1　光照　338</li>
<li>11.1.1　Generate Lightmap UVs 选项　338</li>
<li>11.1.2　Lightmap Static标记　338</li>
<li>11.1.3　光照视图　339</li>
<li>11.1.4　准备烘焙光照的过程　341</li>
<li>11.1.5　Auto选项　342</li>
<li>11.1.6　构建光照贴图　342</li>
<li>11.1.7　Area Light　345</li>
<li>11.2　灯光探测器　346</li>
<li>11.2.1　Light Probe Group　347</li>
<li>11.2.2　Anchor Override　350</li>
<li>11.3　小结　351</li>
<li>第12章　场景分离与合并　353</li>
<li>12.1　场景分离　354</li>
<li>12.2　场景合并　357</li>
<li>第13章　Unity内置网络游戏　361</li>
<li>13.1　网络游戏的定义　362</li>
<li>13.2　网络游戏的物理结构　362</li>
<li>13.3　网络通信协议　363</li>
<li>13.4　Unity内置网络功能　363</li>
<li>13.4.1　网络视图　364</li>
<li>13.4.2　状态同步　364</li>
<li>13.4.3　远程过程调用　365</li>
<li>13.5　Unity网络游戏步骤　366</li>
<li>13.5.1　游戏服务器初始化　366</li>
<li>13.5.2　客户端游戏连接　367</li>
<li>13.5.3　各游戏端点之间的通信　368</li>
<li>13.6　开发网络游戏　368</li>
<li>13.6.1　生成并初始化项目　369</li>
<li>13.6.2　场景制作　369</li>
<li>13.6.3　制作Player　371</li>
<li>13.6.4　Character Controller移动逻辑　371</li>
<li>13.6.5　制作网络管理器　373</li>
<li>13.6.6　构建可执行文件　374</li>
<li>13.6.7　查看连接网络的用户数量　377</li>
<li>13.6.8　制作网络玩家　380</li>
<li>13.6.9　摄像机追踪逻辑　383</li>
<li>13.6.10　平滑的同步处理（OnSerializeNetworkView）　387</li>
<li>13.6.11　发射例程（调用RPC）　392</li>
<li>13.6.12　动画同步　399</li>
<li>13.6.13　探测子弹的碰撞　405</li>
<li>13.6.14　死亡和复活处理　406</li>
<li>13.6.15　终止连接的相关处理　414</li>
<li>13.7　小结　415</li>
<li>第14章　使用Photon Cloud制作网络游戏　417</li>
<li>14.1　第二代Unity网络游戏引擎UNET　418</li>
<li>14.2　第三方网络游戏引擎　418</li>
<li>14.3　PhotonNetwork游戏引擎　418</li>
<li>14.3.1　Photon Server与Photon Cloud　419</li>
<li>14.3.2　加入会员　419</li>
<li>14.4　制作坦克大战游戏　421</li>
<li>14.4.1　坦克移动逻辑　422</li>
<li>14.4.2　履带动画　424</li>
<li>14.4.3　设置摄像机追踪逻辑与摄像机位置　427</li>
<li>14.4.4　旋转炮塔　428</li>
<li>14.4.5　调整炮身角度　431</li>
<li>14.4.6　建立炮弹预设和发射逻辑　432</li>
<li>14.4.7　炮弹发射音效　438</li>
<li>14.5　安装Photon Unity Networking插件　439</li>
<li>14.6　将坦克游戏更改为Photon Cloud版本　441</li>
<li>14.6.1　连接Photon Cloud　442</li>
<li>14.6.2　随机配对　444</li>
<li>14.6.3　制作房间　445</li>
<li>14.6.4　Photon View　447</li>
<li>14.6.5　动态生成坦克　448</li>
<li>14.6.6　构建游戏并测试连接　451</li>
<li>14.6.7　控制自己的坦克　453</li>
<li>14.6.8　平滑移动和旋转处理　454</li>
<li>14.6.9　同步炮塔与炮身　458</li>
<li>14.6.10　发射炮弹　463</li>
<li>14.6.11　坦克被击中时的处理及复活　465</li>
<li>14.7　制作游戏大厅　469</li>
<li>14.7.1　制作大厅场景　469</li>
<li>14.7.2　制作登录UI　471</li>
<li>14.7.3　进入游戏房间　479</li>
<li>14.7.4　制作坦克HUD　484</li>
<li>14.7.5　创建并进入房间　492</li>
<li>14.7.6　构建房间目录UI　497</li>
<li>14.7.7　接收房间列表　504</li>
<li>14.7.8　动态增加按钮事件　516</li>
<li>14.8　战地细节功能　520</li>
<li>14.8.1　显示房间内的玩家数　520</li>
<li>14.8.2　退出房间　523</li>
<li>14.8.3　显示连接日志　525</li>
<li>14.8.4　事件钩子　530</li>
<li>14.9　评分并显示　534</li>
<li>14.10　在Unity中连接数据库　547</li>
<li>　14.10.1 JSON　547</li>
<li>　14.10.2 SimpleJSON　549</li>
<li>　14.10.3 将分数信息保存到数据库　551</li>
<li>　14.10.4 从数据库获取排名信息　554</li>
<li>14.11　小结　557</li>
<li>第15章　提升游戏真实感　559</li>
<li>15.1　布娃娃系统　560</li>
<li>15.1.1　创建项目并下载资源　560</li>
<li>15.1.2　制作舞台　561</li>
<li>15.1.3　生成3D模型的布娃娃系统　562</li>
<li>15.2　触屏　571</li>
<li>15.2.1　ScreenPointToRay函数　571</li>
<li>15.2.2　Touch类　574</li>
<li>15.2.3　Unity Remote4　577</li>
<li>15.3　通过触屏移动　579</li>
<li>15.4　小结　582</li>
<li>附录　数据库　583</li>
<li>1.数据库和数据库管理系统　584</li>
<li>2.数据库服务器　584</li>
<li>3.　SQL　584</li>
<li>4.　DBMS的数据管理　584</li>
<li>5.数据表　585</li>
<li>6.列与行　585</li>
<li>7.　SQL　586</li>
</ul>
<h2 id="2-Unity-3D-NGUI-实战教程"><a href="#2-Unity-3D-NGUI-实战教程" class="headerlink" title="2. Unity 3D NGUI 实战教程 #"></a>2. Unity 3D NGUI 实战教程 #</h2><ul>
<li>第1章 初识NGUI</li>
<li>1.1 游戏UI开发介绍</li>
<li>1.1.1 什么是游戏UI</li>
<li>1.1.2 UI为何如此重要</li>
<li>1.1.3 UI开发的流程</li>
<li>1.1.4 UI开发的难点</li>
<li>1.2 什么是NGUI</li>
<li>1.2.1 NGUI插件介绍</li>
<li>1.2.2 NGUI的强大优势</li>
<li>第2章 NGUI基础</li>
<li>2.1 导入NGUI插件</li>
<li>2.1.1 NGUI版本介绍</li>
<li>2.1.2 NGUI的下载和购买</li>
<li>2.1.3 导入NGUI插件应用</li>
<li>2.1.4 导入常见问题</li>
<li>2.2 认识基本的UI资源</li>
<li>2.2.1 什么是UI精灵（Sprite）</li>
<li>2.2.2 什么是UI图集（Atlas）</li>
<li>2.2.3 什么是UI贴图（Texture）</li>
<li>2.2.4 什么是UI标签（Label）</li>
<li>2.2.5 什么是UI字体（Font）</li>
<li>2.3 制作第一个UI图集</li>
<li>2.3.1 学会解剖UI的资源结构</li>
<li>2.3.2 如何导入切好的美术资源</li>
<li>2.3.3 用Atlas Maker制作图集</li>
<li>2.4 制作第一个UI字体</li>
<li>2.4.1 为什么要制作UI字体</li>
<li>2.4.2 静态字体和动态字体</li>
<li>2.4.3 制作静态字体介绍</li>
<li>2.4.4 制作动态字体介绍</li>
<li>2.5 创建第一个UI</li>
<li>2.5.1 创建一个2D UI</li>
<li>2.5.2 创建一个3D UI</li>
<li>2.5.3 了解UIRoot、UIPanel和UICamera组件</li>
<li>2.6 2DUI和3DUI的工作原理</li>
<li>2.6.1 2DUI的工作原理</li>
<li>2.6.2 3DUI的工作原理</li>
<li>2.6.3 如何判断该选择哪一种UI</li>
<li>2.7 深度（Depth）概念</li>
<li>2.7.1 强化对深度的理解</li>
<li>2.7.2 小心相机的深度</li>
<li>第3章 核心组件</li>
<li>3.1 什么是UI控件</li>
<li>3.2 制作精灵（UISprite）</li>
<li>3.2.1 怎样判断是否应该使用精灵</li>
<li>3.2.2 创建精灵</li>
<li>3.2.3 Sprite组件的设置</li>
<li>3.3 制作标签（Label）</li>
<li>3.3.1 怎样判断是否应当使用标签</li>
<li>3.3.2 创建标签</li>
<li>3.3.3 Label的文字设置</li>
<li>3.4 制作UI纹理（UITexture）</li>
<li>3.4.1 什么情况下使用UITexture</li>
<li>3.4.2 创建纹理</li>
<li>3.4.3 纹理的设置</li>
<li>3.5 制作按钮（Button）</li>
<li>3.5.1 怎样判断应该使用按钮</li>
<li>3.5.2 创建按钮</li>
<li>3.5.3 核心组件BoxCollider</li>
<li>3.5.4 核心组件UIButton</li>
<li>3.5.5 制作按钮的放缩动画</li>
<li>3.5.6 制作按钮的偏移动画</li>
<li>3.5.7 制作按钮的旋转动画</li>
<li>3.5.8 添加按钮单击音效</li>
<li>3.5.9 任何事物都可以变成按钮，不仅仅是UI</li>
<li>3.6 制作进度条（UISlider）</li>
<li>3.6.1 怎样判断是否应当使用进度条</li>
<li>3.6.2 创建进度条</li>
<li>3.6.3 核心组件UISlider设置</li>
<li>3.6.4 进度条的BoxCollider说明</li>
<li>3.7 制作输入框（Input）</li>
<li>3.7.1 怎样判断是否应当使用输入框</li>
<li>3.7.2 创建输入框</li>
<li>3.7.3 核心组件Input设置</li>
<li>3.7.4 输入框使用的一些注意事项</li>
<li>3.8 制作滚动视图（ScrollView）</li>
<li>3.8.1 怎样判断是否应当使用滚动视图</li>
<li>3.8.2 创建滚动视图</li>
<li>3.8.3 滚动视图核心组件UIPanel</li>
<li>3.8.4 滚动视图核心组件UIScrollView</li>
<li>3.8.5 创建一个拖动条</li>
<li>3.8.6 拖动条说明</li>
<li>3.8.7 让视图内的内容可以被拖动</li>
<li>3.8.8 制作滚动视图时的注意事项</li>
<li>3.9 制作复选框（Toggle）</li>
<li>3.9.1 怎样判断是否应当使用复选框</li>
<li>3.9.2 创建复选框</li>
<li>3.9.3 复选框的核心组件UIToggle</li>
<li>3.10 制作下拉菜单（PopupList）</li>
<li>3.10.1 怎样判断是否应当使用下拉菜单</li>
<li>3.10.2 创建下拉菜单</li>
<li>3.10.3 显示当前选中的选项</li>
<li>3.10.4 下拉菜单核心组件PopupList</li>
<li>3.10.5 制作下拉菜单的注意事项</li>
<li>第4章 UI动画</li>
<li>4.1 常见的两种UI动画介绍</li>
<li>4.1.1 要区分UI动画和UI特效两个概念</li>
<li>4.1.2 关于Tween动画</li>
<li>4.1.3 关于Animation动画</li>
<li>4.2 渐隐渐现动画（透明度动画）</li>
<li>4.2.1 透明度动画的介绍和应用</li>
<li>4.2.2 使用透明度动画TweenAlpha</li>
<li>4.2.3 使用透明度动画的注意点</li>
<li>4.3 颜色变化动画（变色动画）</li>
<li>4.3.1 变色动画的介绍和应用</li>
<li>4.3.2 使用颜色动画TweenColor</li>
<li>4.3.3 使用颜色动画的注意点</li>
<li>4.4 位置变换动画（位移动画）</li>
<li>4.4.1 位移动画的介绍和应用</li>
<li>4.4.2 使用位移动画TweenPosition</li>
<li>4.4.3 使用位移动画的注意点</li>
<li>4.5 旋转变化动画（旋转动画）</li>
<li>4.5.1 旋转动画的介绍和应用</li>
<li>4.5.2 使用旋转动画TweenRotation</li>
<li>4.5.3 使用旋转动画的注意点</li>
<li>4.6 大小变化动画（放缩动画）</li>
<li>4.6.1 放缩动画的介绍和应用</li>
<li>4.6.2 使用放缩动画TweenScale</li>
<li>4.6.3 使用放缩动画的注意点</li>
<li>4.7 Tween动画总结</li>
<li>4.8 动画控制组件UIPlayTween</li>
<li>4.8.1 为什么要用UIPlayTween</li>
<li>4.8.2 动画核心组件UIPlayTween讲解</li>
<li>4.8.3 使用UIPlayTween的注意事项</li>
<li>4.9 动画控制组件UIPlayAnimation</li>
<li>4.9.1 为什么要用UIPlayAnimation</li>
<li>4.9.2 为UI添加Animation组件</li>
<li>4.9.3 动画核心组件UIPlayAnimation讲解</li>
<li>4.9.4 使用UIPlayAnimation注意事项</li>
<li>第5章 其他组件</li>
<li>5.1 使用Toggle制作页签</li>
<li>5.1.1 页签的工作原理</li>
<li>5.1.2 一个完整的页签界面</li>
<li>5.1.3 制作两个页签按钮</li>
<li>5.1.4 使用ToggleObjects来记录页签内容</li>
<li>5.1.5 制作页签注意事项</li>
<li>5.2 拖动摄像机来浏览超大界面</li>
<li>5.2.1 拖动相机功能的介绍和应用</li>
<li>5.2.2 核心原理和组件介绍</li>
<li>5.2.3 拖动相机浏览超大界面的注意事项</li>
<li>5.3 使用Grid自动排列UI</li>
<li>5.3.1 自动排列UI的应用</li>
<li>5.3.2 自动排列UI核心组件Grid介绍</li>
<li>5.4 使用DragObject直接拖动物体</li>
<li>5.5 让玩家通过拖动自由改变控件大小</li>
<li>5.6 制作序列帧精灵动画（SpriteAnimation）</li>
<li>5.6.1 什么是序列帧精灵动画</li>
<li>5.6.2 SpriteAnimation组件</li>
<li>第6章 NGUI实战进阶</li>
<li>6.1 UI开发核心问题–UI随屏幕自适应</li>
<li>6.1.1 屏幕分辨率对UI适配的影响</li>
<li>6.1.2 主流设备的屏幕分辨率</li>
<li>6.1.3 自适应核心组件Anchor的使用</li>
<li>6.1.4 使用Anchor的注意事项</li>
<li>6.1.5 正式开发UI之前必须明确的几个问题</li>
<li>6.2 UI元素的相对自适应</li>
<li>6.2.1 什么是UI元素的相对自适应</li>
<li>6.2.2 Anchors的介绍及使用</li>
<li>6.2.3 使用Anchors的范例：背景图的全屏适配</li>
<li>6.2.4 使用Anchors的注意事项</li>
<li>6.3 多摄像机同时协作运行</li>
<li>6.3.1 摄像的渲染层的概念</li>
<li>6.3.2 多摄像机协作的应用范围</li>
<li>6.3.3 如何创建多个UI摄像机</li>
<li>6.3.4 多摄像机协作的注意事项</li>
<li>6.4 巧用九宫格以减少UI资源量</li>
<li>6.4.1 项目安装包大小对项目的影响</li>
</ul>
<h1 id="3-Unity-5实战-使用C-和Unity开发多平台游戏"><a href="#3-Unity-5实战-使用C-和Unity开发多平台游戏" class="headerlink" title="3. Unity 5实战 使用C#和Unity开发多平台游戏 #"></a>3. Unity 5实战 使用C#和Unity开发多平台游戏 #</h1><ul>
<li>第Ⅰ部分起步</li>
<li>第1章初识Unity3</li>
<li>1.1为什么Unity如此优秀4</li>
<li>1.1.1Unity的优势4</li>
<li>1.1.2要意识到的缺点5</li>
<li>1.1.3使用Unity构建的游戏案例6</li>
<li>1.2如何使用Unity9</li>
<li>1.2.1Scene视图、Game视图和工具栏10</li>
<li>1.2.2使用鼠标和键盘11</li>
<li>1.2.3Hierarchy标签和Inspector12</li>
<li>1.2.4Project和Console标签12</li>
<li>1.3开始使用Unity编程13</li>
<li>1.3.1代码在Unity中是如何运行的：脚本组件14</li>
<li>1.3.2使用MonoDevelop，跨平台的IDE15</li>
<li>1.3.3打印到控制台：HelloWorld！16</li>
<li>1.4小结18</li>
<li>第2章构建一个让你置身3D空间的演示19</li>
<li>2.1在开始之前20</li>
<li>2.1.1对项目做计划20</li>
<li>2.1.2了解3D坐标空间21</li>
<li>2.2开始项目：在场景中放置对象22</li>
<li>2.2.1第二步：地板、外墙和内墙22</li>
<li>2.2.2灯光和摄像机25</li>
<li>2.2.3玩家的碰撞器和视口26</li>
<li>2.3让东西移动：应用变换的脚本27</li>
<li>2.3.1图示说明如何通过编程实现旋转27</li>
<li>2.3.2编写代码实现图中演示的运动27</li>
<li>2.3.3本地和全局坐标空间29</li>
<li>2.4用于观察周围的组件脚本：MouseLook30</li>
<li>2.4.1跟踪鼠标运动的水平旋转31</li>
<li>2.4.2在一定范围内的垂直旋转32</li>
<li>2.4.3同时水平和垂直旋转33</li>
<li>2.5键盘输入组件：第一人称控件36</li>
<li>2.5.1响应按下的键36</li>
<li>2.5.2设置独立于计算机运行速度的运动速率37</li>
<li>2.5.3为了碰撞检测，移动CharacterController38</li>
<li>2.5.4调整组件为走路而不是飞翔39</li>
<li>2.6小结41</li>
<li>第3章为3D游戏添加敌人和子弹43</li>
<li>3.1通过射线射击44</li>
<li>3.1.1什么是射线发射44</li>
<li>3.1.2使用命令ScreenPointToRay来发射45</li>
<li>3.1.3为准心和击中点添加可视化提示46</li>
<li>3.2脚本化反应的目标49</li>
<li>3.2.1确定被击中的对象49</li>
<li>3.2.2警告目标它被击中50</li>
<li>3.3基本漫游AI52</li>
<li>3.3.1图解基础AI的工作原理52</li>
<li>3.3.2使用射线发射发现障碍物52</li>
<li>3.3.3跟踪角色状态54</li>
<li>3.4产生敌人预设55</li>
<li>3.4.1什么是预设55</li>
<li>3.4.2创建敌人预设56</li>
<li>3.4.3在不可见的SceneController中实例化57</li>
<li>3.5通过实例化对象进行射击59</li>
<li>3.5.1创建子弹预设59</li>
<li>3.5.2发射子弹并和目标碰撞60</li>
<li>3.5.3伤害玩家63</li>
<li>3.6小结63</li>
<li>第4章为游戏开发图形65</li>
<li>4.1了解美术资源65</li>
<li>4.2构建基础3D场景：白盒67</li>
<li>4.2.1白盒的解释68</li>
<li>4.2.2为关卡绘制地板平面图68</li>
<li>4.2.3根据平面图布局几何体69</li>
<li>4.3使用2D图像给场景贴图70</li>
<li>4.3.1选择文件格式71</li>
<li>4.3.2导入图像文件72</li>
<li>4.3.3应用图像73</li>
<li>4.4使用贴图图像产生天空视觉效果75</li>
<li>4.4.1什么是天空盒75</li>
<li>4.4.2创建一个新天空盒材质76</li>
<li>4.5使用自定义3D模型77</li>
<li>4.5.1选择文件格式78</li>
<li>4.5.2导出和导入模型79</li>
<li>4.6使用粒子系统创建效果81</li>
<li>4.6.1调整默认效果的参数82</li>
<li>4.6.2为火焰应用新贴图83</li>
<li>4.6.3将粒子效果附加到3D对象上84</li>
<li>4.7小结85</li>
<li>第Ⅱ部分轻松工作</li>
<li>第5章使用Unity新的2D功能构建一款记忆力游戏89</li>
<li>5.1设置2D图形90</li>
<li>5.1.1为项目做准备90</li>
<li>5.1.2显示2D图像(亦称精灵)92</li>
<li>5.1.3将摄像机切换为2D模式94</li>
<li>5.2构建卡片对象并让它响应单击95</li>
<li>5.2.1从精灵构建对象95</li>
<li>5.2.2鼠标输入代码96</li>
<li>5.2.3当单击时显示卡片96</li>
<li>5.3显示不同的卡片图像97</li>
<li>5.3.1通过程序加载图像97</li>
<li>5.3.2通过不可见的SceneController来设置图像98</li>
<li>5.3.3实例化一个网格的卡片100</li>
<li>5.3.4打乱卡片101</li>
<li>5.4实现匹配和匹配得分103</li>
<li>5.4.1保存并比较翻开的卡片104</li>
<li>5.4.2隐藏错误卡片104</li>
<li>5.4.3显示积分的文本105</li>
<li>5.5重启按钮106</li>
<li>5.5.1使用SendMessage编写UIButton组件107</li>
<li>5.5.2从SceneController中调用LoadLevel109</li>
<li>5.6小结110</li>
<li>第6章在3D游戏中放置2D图形用户界面111</li>
<li>6.1在开始写代码之前……112</li>
<li>6.1.1直接模式GUI还是高级2D界面112</li>
<li>6.1.2规划布局113</li>
<li>6.1.3导入UI图像114</li>
<li>6.2设置GUI显示114</li>
<li>6.2.1为界面创建画布115</li>
<li>6.2.2按钮、图像和文本标签116</li>
<li>6.2.3控制UI元素的位置118</li>
<li>6.3编写UI中的交互119</li>
<li>6.3.1编写不可见的UIController120</li>
<li>6.3.2创建弹出窗口121</li>
<li>6.3.3使用滑动条和输入域设置值124</li>
<li>6.4通过响应事件更新游戏126</li>
<li>6.4.1集成事件系统127</li>
<li>6.4.2从场景中广播和侦听事件127</li>
<li>6.4.3从HUD广播和侦听事件128</li>
<li>6.5小结130</li>
<li>第7章创建第三人称3D游戏：玩家移动和动画131</li>
<li>7.1调整摄像机视图为第三人称视角133</li>
<li>7.1.1导入一个用于观察的角色133</li>
<li>7.1.2将阴影添加到场景134</li>
<li>7.1.3摄像机环绕玩家角色135</li>
<li>7.2编写程序控制camera-relative的移动137</li>
<li>7.2.1旋转角色，以朝向移动方向138</li>
<li>7.2.2朝着方向向前移动140</li>
<li>7.3实现跳跃动作141</li>
<li>7.3.1应用垂直速度和加速度142</li>
<li>7.3.2修改地面检测来处理边缘和斜坡143</li>
<li>7.4设置玩家角色上的动画146</li>
<li>7.4.1在导入的模型上定义动画剪辑148</li>
<li>7.4.2为动画创建动画控制器149</li>
<li>7.4.3编写操作Animator组件的代码153</li>
<li>7.5小结154</li>
<li>第8章在游戏中添加交互设施和物件155</li>
<li>8.1创建门和其他设施156</li>
<li>8.1.1由按键控制开/关的门156</li>
<li>8.1.2在开门之前检查距离和朝向157</li>
<li>8.1.3创建一个变色监控器159</li>
<li>8.2通过碰撞与对象交互160</li>
<li>8.2.1和具有物理功能的障碍物碰撞160</li>
<li>8.2.2用一个压力板来触发门161</li>
<li>8.2.3收集当前关卡游戏中分散的物件163</li>
<li>8.3管理仓库数据和游戏状态165</li>
<li>8.3.1设置玩家和仓库管理器165</li>
<li>8.3.2编程实现游戏管理器166</li>
<li>8.3.3把物品存储在集合对象中：List与Dictionary170</li>
<li>8.4使用和装备物品的仓库UI173</li>
<li>8.4.1在UI中显示仓库物品173</li>
<li>8.4.2装备一个用来开门的钥匙175</li>
<li>8.4.3通过使用血量包来恢复玩家的血量177</li>
<li>8.5小结178</li>
<li>第Ⅲ部分冲刺阶段</li>
<li>第9章将游戏连接到互联网181</li>
<li>9.1创建户外场景182</li>
<li>9.1.1使用天空盒生成天空视觉效果182</li>
<li>9.1.2通过代码设置大气环境183</li>
<li>9.2从互联网服务下载天气数据185</li>
<li>9.2.1使用协程请求WWW数据188</li>
<li>9.2.2解析XML192</li>
<li>9.2.3解析JSON193</li>
<li>9.2.4基于天气数据影响场景195</li>
<li>9.3添加一个网络布告栏196</li>
<li>9.3.1从互联网加载图像196</li>
<li>9.3.2在布告栏上显示图像199</li>
<li>9.3.3缓存下载的图像以供重用200</li>
<li>9.4将数据发送到Web服务器201</li>
<li>9.4.1跟踪当前的天气：发送post请求202</li>
<li>9.4.2PHP中的服务器端代码204</li>
<li>9.5小结204</li>
<li>第10章播放音频：音效和音乐205</li>
<li>10.1导入音效206</li>
<li>10.1.1所支持的文件格式206</li>
<li>10.1.2导入音频文件207</li>
<li>10.2播放音效208</li>
<li>10.2.1音频剪辑、音源和声音侦听器208</li>
<li>10.2.2设定一个循环声音209</li>
<li>10.2.3从代码触发音效210</li>
<li>10.3音频控制接口211</li>
<li>10.3.1建立中心AudioManager212</li>
<li>10.3.2音量控制UI214</li>
<li>10.3.3播放UI声音217</li>
<li>10.4背景音乐218</li>
<li>10.4.1播放循环音乐218</li>
<li>10.4.2独立控制音乐的音量221</li>
<li>10.4.3歌曲间的淡入淡出223</li>
<li>10.5小结226</li>
<li>第11章将各部分整合为一个完整的游戏227</li>
<li>11.1再次利用项目来构建角色扮演RPG228</li>
<li>11.1.1将多个项目的资源和代码装配在一起228</li>
<li>11.1.2编写指向-单击的控件：移动和设备231</li>
<li>11.1.3使用新界面替换旧GUI235</li>
<li>11.2开发总体的游戏结构241</li>
<li>11.2.1控制任务流和多关卡242</li>
<li>11.2.2通过到达退出条件完成一个关卡245</li>
<li>11.2.3当被敌人捕捉时关卡失败247</li>
<li>11.3处理玩家游戏过程中的进度249</li>
<li>11.3.1保存并加载玩家进度249</li>
<li>11.3.2通过完成三个关卡打败游戏253</li>
<li>11.4小结255</li>
<li>第12章将游戏部署到玩家的设备255</li>
<li>12.1构建桌面环境：Windows、Mac和Linux259</li>
<li>12.1.1构建应用259</li>
<li>12.1.2调整PlayerSettings：设置游戏的名称和图标260</li>
<li>12.1.3平台依赖的编译261</li>
<li>12.2为Web构建游戏262</li>
<li>12.2.1UnityPlayer和HTML/WebGL262</li>
<li>12.2.2构建Unity文件和一个测试Web页面262</li>
<li>12.2.3与浏览器中的JavaScript通信263</li>
<li>12.3构建移动应用的平台：iOS和Android264</li>
<li>12.3.1设置构建工具265</li>
<li>12.3.2贴图压缩268</li>
<li>12.3.3开发插件269</li>
<li>12.4小结277</li>
<li>附录A场景导航和键盘快捷键279</li>
<li>A.1使用鼠标进行场景导航279</li>
<li>A.2一般使用键盘快捷键280</li>
<li>附录B与Unity一同使用的外部工具281</li>
<li>B.1编程工具281</li>
<li>B.1.1VisualStudio281</li>
<li>B.1.2Xcode281</li>
<li>B.1.3AndroidSDK282</li>
<li>B.1.4SVN、Git或Mercurial282</li>
<li>B.23D美术应用282</li>
<li>B.2.1Maya282</li>
<li>B.2.23dsMax282</li>
<li>B.2.3Blender283</li>
<li>B.32D图像编辑器283</li>
<li>B.3.1Photoshop283</li>
<li>B.3.2GIMP283</li>
<li>B.3.3TexturePacker283</li>
<li>B.4音频软件283</li>
<li>B.4.1ProTools284</li>
<li>B.4.2Audacity284</li>
<li>附录C在Blender中建模一个板凳285</li>
<li>C.1构建网格几何体285</li>
<li>C.2模型贴图映射288</li>
<li>附录D在线学习资源293</li>
<li>D.1附加的指南293</li>
<li>D.2代码库294</li>
<li>后序297</li>
</ul>
<h1 id="4-Unity-3D人工智能编程"><a href="#4-Unity-3D人工智能编程" class="headerlink" title="4. Unity 3D人工智能编程 #"></a>4. Unity 3D人工智能编程 #</h1><ul>
<li>前　言</li>
<li>第1章　人工智能导论    1</li>
<li>1.1　人工智能    1</li>
<li>1.2　游戏中的人工智能    2</li>
<li>1.3　人工智能技术    3</li>
<li>1.3.1　有限状态机    3</li>
<li>1.3.2　人工智能中的随机性和概率    5</li>
<li>1.3.3　感应器系统    6</li>
<li>1.3.4　群组、蜂拥和羊群效应    7</li>
<li>1.3.5　路径跟随和引导    8</li>
<li>1.3.6　A*寻路算法    9</li>
<li>1.3.7　导航网格    16</li>
<li>1.3.8　行为树    18</li>
<li>1.3.9　运动    20</li>
<li>1.3.10　Dijkstra算法    23</li>
<li>1.4　本章小结    23</li>
<li>第2章　有限状态机    24</li>
<li>2.1　玩家的坦克    24</li>
<li>2.1.1 　PlayerTankController类    25</li>
<li>2.1.2　初始化    26</li>
<li>2.2　子弹类    29</li>
<li>2.3　设置航点    31</li>
<li>2.4　抽象有限状态机类    32</li>
<li>2.5　敌方坦克的人工智能    34</li>
<li>2.5.1　巡逻状态    36</li>
<li>2.5.2　追逐状态    38</li>
<li>2.5.3　攻击状态    38</li>
<li>2.5.4　死亡状态    40</li>
<li>2.6　使用有限状态机框架    42</li>
<li>2.6.1　AdvanceFSM类    42</li>
<li>2.6.2　FSMState类    43</li>
<li>2.6.3　状态类    44</li>
<li>2.6.4　NPCTankController 类    46</li>
<li>2.7　本章小结    48</li>
<li>第3章　随机性和概率    49</li>
<li>3.1　随机性    50</li>
<li>3.2　概率的定义    52</li>
<li>3.2.1　独立与关联事件    53</li>
<li>3.2.2　条件概率    53</li>
<li>3.3　人物个性    56</li>
<li>3.4　有限状态机和概率    57</li>
<li>3.5　动态人工智能    59</li>
<li>3.6　示例老虎机    60</li>
<li>3.6.1　 随机老虎机    60</li>
<li>3.6.2　加权概率    63</li>
<li>3.7　本章小结    68</li>
<li>第4章　感应器的实现 70</li>
<li>4.1　基本的感觉系统    71</li>
<li>4.2　场景设置    72</li>
<li>4.3　玩家的坦克与切面    73</li>
<li>4.3.1　玩家的坦克    74</li>
<li>4.3.2　切面    75</li>
<li>4.4　人工智能角色    76</li>
<li>4.4.1　感观    77</li>
<li>4.4.2　视觉    78</li>
<li>4.4.3　触觉    80</li>
<li>4.5　测试    82</li>
<li>4.6　本章小结    83</li>
<li>第5章　群组行为    84</li>
<li>5.1　岛屿示例中的群组行为    84</li>
<li>5.1.1　个体的行为    85</li>
<li>5.1.2　控制器    90</li>
<li>5.2　替代实现    92</li>
<li>5.3　本章小结    99</li>
<li>第6章　路径跟随和引导行为    100</li>
<li>6.1　跟随一条路径    100</li>
<li>6.1.1　路径脚本    102</li>
<li>6.1.2　路径跟随    103</li>
<li>6.2　避开障碍物    106</li>
<li>6.2.1　添加定制图层    107</li>
<li>6.2.2　避开障碍    108</li>
<li>6.3　本章小结    113</li>
<li>第7章　A*寻路算法    114</li>
<li>7.1　回顾A*寻路算法    114</li>
<li>7.2　实现    116</li>
<li>7.2.1　Node    116</li>
<li>7.2.2　PriorityQueue    117</li>
<li>7.2.3　GridManager    118</li>
<li>7.2.4　AStar    123</li>
<li>7.2.5　TestCode类    126</li>
<li>7.3　场景设置    128</li>
<li>7.4　测试    131</li>
<li>7.5　本章小结    132</li>
<li>第8章　导航网格    133</li>
<li>8.1　简介    134</li>
<li>8.2　设置地图    134</li>
<li>8.2.1　Navigation Static 135</li>
<li>8.2.2　烘焙导航网格    135</li>
<li>8.2.3　导航网格代理    136</li>
<li>8.3　有斜坡的场景    139</li>
<li>8.4　NavMeshLayers    141</li>
<li>8.5　分离网格链接    144</li>
<li>8.5.1　生成分离网格链接    145</li>
<li>8.5.2　手动生成分离网格链接    146</li>
<li>8.6　本章小结    148</li>
<li>第9章　行为树    149</li>
<li>9.1　Behave插件    149</li>
<li>9.2　工作流    151</li>
<li>9.3　行为节点    153</li>
<li>9.4　与脚本的接口    155</li>
<li>9.5　装饰节点    158</li>
<li>9.6　Behave调试器    160</li>
<li>9.7　顺序节点    160</li>
<li>9.8　探索Behave的结果    162</li>
<li>9.9　选择节点    163</li>
<li>9.10　优先级选择节点    166</li>
<li>9.11　并行节点    168</li>
<li>9.12　引用    169</li>
<li>9.13　机器人与外星人项目    170</li>
<li>9.14　本章小结    173</li>
<li>第10章　融会贯通    174</li>
<li>10.1　场景设置    175</li>
<li>10.2　车辆    177</li>
<li>10.2.1　玩家控制的车辆    178</li>
<li>10.2.2　人工智能车辆控制器    180</li>
<li>10.2.3　有限状态机    182</li>
<li>10.3　武器    187</li>
<li>10.3.1　枪    187</li>
<li>10.3.2　子弹    189</li>
<li>10.3.3　发射器    191</li>
<li>10.3.4　导弹    193</li>
<li>10.4　本章小结    195</li>
</ul>
<h1 id="5-Unity官方案例精讲"><a href="#5-Unity官方案例精讲" class="headerlink" title="5. Unity官方案例精讲 #"></a>5. Unity官方案例精讲 #</h1><ul>
<li>第 1 章 C# 脚本编程基础 ………………. 1</li>
<li>1.1 配置脚本开发环境 ………………………………..2</li>
<li>1.1.1 配置 Visual Studio …………………….2</li>
<li>1.1.2 配置MonoDevelop ……………………6</li>
<li>1.1.3 脚本的创建 ……………………………..8</li>
<li>1.2 变量、数组与函数 ………………………………..9</li>
<li>1.2.1 变量的声明与使用 ……………………9</li>
<li>1.2.2 数组的声明与使用 ………………….11</li>
<li>1.2.3 函数的声明与使用 ………………….12</li>
<li>1.3 语句、表达式与运算符 ……………………. 14</li>
<li>1.3.1 语句 ……………………………………….14</li>
<li>1.3.2 表达式 ……………………………………16</li>
<li>1.3.3 运算符 ……………………………………16</li>
<li>1.4 协程（Coroutine） ………………………………. 18</li>
<li>1.5 类与类的使用 ……………………………………… 21</li>
<li>1.6 输出调试信息 ……………………………………… 22</li>
<li>1.7 C# 脚本示例 ………………………………………… 22</li>
<li>1.8 Unity 脚本事件执行顺序 ………………….. 26</li>
<li>1.9 脚本模板与脚本编码 ………………………… 28</li>
<li>1.10 Unity 5 脚本升级 ……………………………… 29</li>
<li>第 2 章 JavaScript 脚本编程基础 ….. 31</li>
<li>2.1 JavaScript 脚本编程基础 ………………….. 32</li>
<li>2.2 变量、数组与函数 …………………………….. 32</li>
<li>2.2.1 变量 ……………………………………….32</li>
<li>2.2.2 数组 ……………………………………….33</li>
<li>2.2.3 函数 ……………………………………….35</li>
<li>2.3 表达式、语句与运算符 ……………………. 37</li>
<li>2.4 JavaScript 脚本示例 …………………………… 39</li>
<li>2.5 JavaScript 脚本与 C# 脚本的交互 …… 41</li>
<li>第 3 章星际航行游戏——JSpace Shooter ……………… 45</li>
<li>3.1 导入模型、贴图和材质 ……………………. 46</li>
<li>3.1.1 导入资源包文件 ……………………..46</li>
<li>3.1.2 创建飞船对象 …………………………49</li>
<li>3.1.3 设置摄像机参数 ……………………..50</li>
<li>3.1.4 添加图片背景 …………………………50</li>
<li>3.1.5 添加粒子背景效果 ………………….52</li>
<li>3.2 编写脚本代码 ……………………………………… 53</li>
<li>3.2.1 键盘控制飞船移动 ………………….53</li>
<li>3.2.2 实现射击行为（Shot） …………….57</li>
<li>3.2.3 添加小行星（Asteroid） …………..61</li>
<li>3.3 添加音频 ……………………………………………… 69</li>
<li>3.3.1 添加碰撞爆炸音频 ………………….69</li>
<li>3.3.2 添加飞船射击音频 ………………….69</li>
<li>3.3.3 添加背景音效 …………………………70</li>
<li>3.4 添加计分文本 ……………………………………… 71</li>
<li>3.4.1 添加计分 Text 组件 …………………71</li>
<li>3.4.2 添加计分功能 …………………………72</li>
<li>3.5 游戏结束与重新开始 ………………………… 74</li>
<li>3.5.1 添加游戏结束的 Text 组件 ………74</li>
<li>3.5.2 添加结束游戏的功能 ………………75</li>
<li>3.5.3 添加重新开始的 Text 组件 ………76</li>
<li>3.5.4 添加重新开始游戏的功能 ……….77</li>
<li>第 4 章潜行游戏——Stealth ……….. 79</li>
<li>4.1 加载场景 …………………………………………… 80</li>
<li>4.1.1 创建场景 ………………………………..80</li>
<li>4.1.2 添加场景元素 …………………………80</li>
<li>4.1.3 添加灯光 ………………………………..82</li>
<li>4.1.4 烘焙场景Lightmaps ………………..84</li>
<li>4.1.5 添加 Tag 管理类 ……………………..87</li>
<li>4.1.6 添加转场效果 …………………………87</li>
<li>4.1.7 添加游戏控制器GameController ……………………….89</li>
<li>4.1.8 添加 CCTV Camera …………………92</li>
<li>4.1.9 添加 Laser Grid ……………………….94</li>
<li>4.2 导入和配置人物角色 ………………………… 97</li>
<li>4.2.1 导入角色模型 …………………………97</li>
<li>4.2.2 设置角色动画 …………………………98</li>
<li>4.2.3 创建动画参数管理类 ………………99</li>
<li>4.2.4 添加控制角色运动功能 …………101</li>
<li>4.2.5 添加控制摄像机跟随的功能 ….104</li>
<li>4.3 主角与环境交互 ………………………………..107</li>
<li>4.3.1 添加控制开关台的功能 …………107</li>
<li>4.3.2 添加管理房间钥匙卡的功能 ….110</li>
<li>4.3.3 添加控制单开门的功能 …………112</li>
<li>4.3.4 添加控制双开门的功能 …………115</li>
<li>4.4 主角与敌人交互 ………………………………..116</li>
<li>4.4.1 添加管理角色生命值的功能 ….116</li>
<li>4.4.2 添加敌人角色模型 ………………..118</li>
<li>4.4.3 添加敌人自动搜索角色的功能 …………………………120</li>
<li>4.4.4 添加控制敌人运动功能 …………123</li>
<li>4.4.5 添加控制敌人射击的功能 ……..126</li>
<li>第 5 章粒子碰撞回调功能——Particle Callbacks ………….. 129</li>
<li>5.1 Shuriken 粒子系统介绍 ……………………130</li>
<li>5.2 加载场景 …………………………………………….131</li>
<li>5.3 创建粒子效果 …………………………………….134</li>
<li>5.3.1 创建燃烧时冒烟的粒子效果 …..134</li>
<li>5.3.2 创建燃烧时火星四溅的粒子效果 ………………………….139</li>
<li>5.3.3 火焰大小控制 ……………………….140</li>
<li>5.3.4 创建洒水的粒子效果 …………….143</li>
<li>5.3.5 控制洒水位置 ……………………….146</li>
<li>5.4 碰撞回调函数解析 ……………………………148</li>
<li>5.5 粒子碰撞回调函数应用案例 …………..153</li>
<li>5.5.1 水滴与桶盖碰撞的处理 …………153</li>
<li>5.5.2 实现水滴与燃烧桶碰撞熄灭火焰的效果 …………………….155</li>
<li>第 6 章Mecanim动画系统介绍——Mecanim Example Scenes ….. 159</li>
<li>6.1 Mecanim动画系统简介 …………………..160</li>
<li>6.1.1 Mecanim动画系统的工作流 ….160</li>
<li>6.1.2 Mecanim动画系统中的术语 ….160</li>
</ul>
<h1 id="6-Unity-Shader入门精要"><a href="#6-Unity-Shader入门精要" class="headerlink" title="6. Unity Shader入门精要 #"></a>6. Unity Shader入门精要 #</h1><ul>
<li>第1篇　基础篇</li>
<li></li>
<li>第1章　欢迎来到Shader的世界　2</li>
<li>1．1　程序员的三大浪漫　2</li>
<li>1．2　本书结构　3</li>
<li></li>
<li>第2章　渲染流水线　5</li>
<li>2．1　综述　5</li>
<li>2．1．1　什么是流水线　5</li>
<li>2．1．2　什么是渲染流水线　6</li>
<li>2．2　CPU和GPU之间的通信　7</li>
<li>2．2．1　把数据加载到显存中　7</li>
<li>2．2．2　设置渲染状态　8</li>
<li>2．2．3　调用Draw Call　8</li>
<li>2．3　GPU流水线　9</li>
<li>2．3．1　概述　9</li>
<li>2．3．2　顶点着色器　10</li>
<li>2．3．3　裁剪　11</li>
<li>2．3．4　屏幕映射　11</li>
<li>2．3．5　三角形设置　12</li>
<li>2．3．6　三角形遍历　13</li>
<li>2．3．7　片元着色器　13</li>
<li>2．3．8　逐片元操作　14</li>
<li>2．3．9　总结　17</li>
<li>2．4　一些容易困惑的地方　18</li>
<li>2．4．1　什么是OpenGL/DirectX　18</li>
<li>2．4．2　什么是HLSL、GLSL、CG　19</li>
<li>2．4．3　什么是Draw Call　20</li>
<li>2．4．4　什么是固定管线渲染　22</li>
<li>2．5　那么，你明白什么是Shader了吗　23</li>
<li>2．6　扩展阅读　23</li>
<li></li>
<li>第3章　Unity Shader基础　24</li>
<li>3．1　Unity Shader概述　25</li>
<li>3．1．1　一对好兄弟：材质和Unity Shader　25</li>
<li>3．1．2　Unity中的材质　26</li>
<li>3．1．3　Unity中的Shader　26</li>
<li>3．2　Unity Shader的基础：ShaderLab　28</li>
<li>3．3　Unity Shader的结构　29</li>
<li>3．3．1　给我们的Shader起个名字　29</li>
<li>3．3．2　材质和Unity Shader的桥梁：Properties　29</li>
<li>3．3．3　重量级成员：SubShader　31</li>
<li>3．3．4　留一条后路：Fallback　33</li>
<li>3．3．5　ShaderLab还有其他的</li>
<li>语义吗　33</li>
<li>3．4　Unity Shader的形式　33</li>
<li>3．4．1　Unity的宠儿：表面着色器　34</li>
<li>3．4．2　最聪明的孩子：顶点/片元着</li>
<li>色器　35</li>
<li>3．4．3　被抛弃的角落：固定函数着</li>
<li>色器　35</li>
<li>3．4．4　选择哪种Unity Shader形式　36</li>
<li>3．5　本书使用的Unity Shader形式　36</li>
<li>3．6　答疑解惑　36</li>
<li>3．6．1　Unity Shader != 真正的Shader　36</li>
<li>3．6．2　Unity Shader和CG/HLSL之间的关系　37</li>
<li>3．6．3　我可以使用GLSL来写吗　38</li>
<li>3．7　扩展阅读　38</li>
<li></li>
<li>第4章　学习Shader所需的数学基础　39</li>
<li>4．1　背景：农场游戏　39</li>
<li>4．2　笛卡儿坐标系　40</li>
<li>4．2．1　二维笛卡儿坐标系　40</li>
<li>4．2．2　三维笛卡儿坐标系　41</li>
<li>4．2．3　左手坐标系和右手坐标系　42</li>
<li>4．2．4　Unity使用的坐标系　44</li>
<li>4．2．5　练习题　45</li>
<li>4．3　点和矢量　45</li>
<li>4．3．1　点和矢量的区别　46</li>
<li>4．3．2　矢量运算　47</li>
<li>4．3．3　练习题　53</li>
<li>4．4　矩阵　54</li>
<li>4．4．1　矩阵的定义　54</li>
<li>4．4．2　和矢量联系起来　55</li>
<li>4．4．3　矩阵运算　55</li>
<li>4．4．4　特殊的矩阵　57</li>
<li>4．4．5　行矩阵还是列矩阵　60</li>
<li>4．4．6　练习题　61</li>
<li>4．5　矩阵的几何意义：变换　62</li>
<li>4．5．1　什么是变换　62</li>
<li>4．5．2　齐次坐标　63</li>
<li>4．5．3　分解基础变换矩阵　63</li>
<li>4．5．4　平移矩阵　64</li>
<li>4．5．5　缩放矩阵　64</li>
<li>4．5．6　旋转矩阵　65</li>
<li>4．5．7　复合变换　66</li>
<li>4．6　坐标空间　67</li>
<li>4．6．1　为什么要使用这么多不同的坐标空间　68</li>
<li>4．6．2　坐标空间的变换　68</li>
<li>4．6．3　顶点的坐标空间变换过程　72</li>
<li>4．6．4　模型空间　73</li>
<li>4．6．5　世界空间　73</li>
<li>4．6．6　观察空间　75</li>
<li>4．6．7　裁剪空间　77</li>
<li>4．6．8　屏幕空间　83</li>
<li>4．6．9　总结　85</li>
<li>4．7　法线变换　86</li>
<li>4．8　Unity Shader的内置变量（数学篇）　87</li>
<li>4．8．1　变换矩阵　87</li>
<li>4．8．2　摄像机和屏幕参数　88</li>
<li>4．9　答疑解惑　89</li>
<li>4．9．1　使用3×3还是4×4的</li>
<li>变换矩阵　89</li>
<li>4．9．2　CG中的矢量和矩阵类型　89</li>
<li>4．9．3　Unity中的屏幕坐标：ComputeScreenPos/VPOS/</li>
<li>WPOS　90</li>
<li>4．10　扩展阅读　93</li>
<li>4．11　练习题答案　93</li>
<li>第2篇　初级篇</li>
<li></li>
<li>第5章　开始Unity Shader学习之旅　100</li>
<li>5．1　本书使用的软件和环境　100</li>
<li>5．2　一个最简单的顶点/片元着色器　100</li>
<li>5．2．1　顶点/片元着色器的基本</li>
<li>结构　101</li>
<li>5．2．2　模型数据从哪里来　103</li>
<li>5．2．3　顶点着色器和片元着色器之间如何通信　104</li>
<li>5．2．4　如何使用属性　105</li>
<li>5．3　强大的援手：Unity提供的内置文件和变量　107</li>
<li>5．3．1　内置的包含文件　107</li>
<li>5．3．2　内置的变量　109</li>
<li>5．4　Unity提供的CG/HLSL语义　109</li>
<li>5．4．1　什么是语义　109</li>
<li>5．4．2　Unity支持的语义　110</li>
<li>5．4．3　如何定义复杂的变量类型　110</li>
<li>5．5　程序员的烦恼：Debug　111</li>
<li>5．5．1　使用假彩色图像　111</li>
<li>5．5．2　利用神器：Visual Studio　113</li>
<li>5．5．3　最新利器：帧调试器　113</li>
<li>5．6　小心：渲染平台的差异　115</li>
<li>5．6．1　渲染纹理的坐标差异　115</li>
<li>5．6．2　Shader的语法差异　116</li>
<li>5．6．3　Shader的语义差异　117</li>
<li>5．6．4　其他平台差异　117</li>
<li>5．7　Shader整洁之道　117</li>
<li>5．7．1　float、half还是fixed　117</li>
<li>5．7．2　规范语法　118</li>
<li>5．7．3　避免不必要的计算　118</li>
<li>5．7．4　慎用分支和循环语句　119</li>
<li>5．7．5　不要除以0　119</li>
<li>5．8　扩展阅读　120</li>
<li></li>
<li>第6章　Unity中的基础光照　121</li>
<li>6．1　我们是如何看到这个世界的　121</li>
<li>6．1．1　光源　121</li>
<li>6．1．2　吸收和散射　122</li>
<li>6．1．3　着色　122</li>
<li>6．1．4　BRDF光照模型　123</li>
<li>6．2　标准光照模型　123</li>
<li>6．2．1　环境光　123</li>
<li>6．2．2　自发光　124</li>
<li>6．2．3　漫反射　124</li>
<li>6．2．4　高光反射　124</li>
<li>6．2．5　逐像素还是逐顶点　125</li>
<li>6．2．6　总结　125</li>
<li>6．3　Unity中的环境光和自发光　126</li>
<li>6．4　在Unity Shader中实现漫反射光照</li>
<li>模型　126</li>
<li>6．4．1　实践：逐顶点光照　126</li>
<li>6．4．2　实践：逐像素光照　129</li>
<li>6．4．3　半兰伯特模型　130</li>
<li>6．5　在Unity Shader中实现高光反射</li>
<li>光照模型　131</li>
<li>6．5．1　实践：逐顶点光照　132</li>
<li>6．5．2　实践：逐像素光照　134</li>
<li>6．5．3　Blinn-Phong光照模型　135</li>
<li>6．6　召唤神龙：使用Unity内置的</li>
<li>函数　136</li>
<li></li>
<li>第7章　基础纹理　139</li>
<li>7．1　单张纹理　140</li>
<li>7．1．1　实践　140</li>
<li>7．1．2　纹理的属性　142</li>
<li>7．2　凹凸映射　146</li>
<li>7．2．1　高度纹理　146</li>
<li>7．2．2　法线纹理　146</li>
<li>7．2．3　实践　148</li>
<li>7．2．4　Unity中的法线纹理类型　154</li>
<li>7．3　渐变纹理　155</li>
<li>7．4　遮罩纹理　158</li>
<li>7．4．1　实践　159</li>
<li>7．4．2　其他遮罩纹理　161</li>
<li></li>
<li>第8章　透明效果　162</li>
<li>8．1　为什么渲染顺序很重要　163</li>
<li>8．2　Unity Shader的渲染顺序　164</li>
<li>8．3　透明度测试　165</li>
<li>8．4　透明度混合　169</li>
<li>8．5　开启深度写入的半透明效果　171</li>
<li>8．6　ShaderLab的混合命令　173</li>
<li>8．6．1　混合等式和参数　173</li>
<li>8．6．2　混合操作　174</li>
<li>8．6．3　常见的混合类型　175</li>
<li>8．7　双面渲染的透明效果　176</li>
<li>8．7．1　透明度测试的双面渲染　176</li>
<li>8．7．2　透明度混合的双面渲染　176</li>
<li>第3篇　中级篇</li>
<li></li>
<li>第9章　更复杂的光照　180</li>
<li>9．1　Unity的渲染路径　180</li>
<li>9．1．1　前向渲染路径　182</li>
<li>9．1．2　顶点照明渲染路径　185</li>
<li>9．1．3　延迟渲染路径　186</li>
<li>9．1．4　选择哪种渲染路径　188</li>
<li>9．2　Unity的光源类型　188</li>
<li>9．2．1　光源类型有什么影响　189</li>
<li>9．2．2　在前向渲染中处理不同的</li>
<li>光源类型　190</li>
<li>9．3　Unity的光照衰减　195</li>
<li>9．3．1　用于光照衰减的纹理　196</li>
<li>9．3．2　使用数学公式计算衰减　196</li>
<li>9．4　Unity的阴影　196</li>
<li>9．4．1　阴影是如何实现的　197</li>
<li>9．4．2　不透明物体的阴影　198</li>
<li>9．4．3　使用帧调试器查看阴影绘制过程　202</li>
<li>9．4．4　统一管理光照衰减和阴影　204</li>
<li>9．4．5　透明度物体的阴影　206</li>
<li>9．5　本书使用的标准Unity Shader　209</li>
<li></li>
<li>第10章　高级纹理　210</li>
<li>10．1　立方体纹理　210</li>
<li>10．1．1　天空盒子　210</li>
<li>10．1．2　创建用于环境映射的立方体</li>
<li>纹理　212</li>
<li>10．1．3　反射　213</li>
<li>10．1．4　折射　215</li>
<li>10．1．5　菲涅耳反射　217</li>
<li>10．2　渲染纹理　219</li>
<li>10．2．1　镜子效果　219</li>
<li>10．2．2　玻璃效果　220</li>
<li>10．2．3　渲染纹理 vs． GrabPass　224</li>
<li>10．3　程序纹理　225</li>
<li>10．3．1　在Unity中实现简单的程序</li>
<li>纹理　225</li>
<li>10．3．2　Unity的程序材质　228</li>
<li></li>
<li>第11章　让画面动起来　230</li>
<li>11．1　Unity Shader中的内置变量</li>
<li>（时间篇）　230</li>
<li>11．2　纹理动画　230</li>
<li>11．2．1　序列帧动画　230</li>
<li>11．2．2　滚动的背景　233</li>
<li>11．3　顶点动画　234</li>
<li>11．3．1　流动的河流　234</li>
<li>11．3．2　广告牌　236</li>
<li>11．3．3　注意事项　239</li>
<li>第4篇　高级篇</li>
<li></li>
<li>第12章　屏幕后处理效果　244</li>
<li>12．1　建立一个基本的屏幕后处理脚本</li>
<li>系统　244</li>
<li>12．2　调整屏幕的亮度、饱和度和</li>
<li>对比度　246</li>
<li>12．3　边缘检测　249</li>
<li>12．3．1　什么是卷积　249</li>
<li>12．3．2　常见的边缘检测算子　249</li>
<li>12．3．3　实现　250</li>
<li>12．4　高斯模糊　253</li>
<li>12．4．1　高斯滤波　253</li>
<li>12．4．2　实现　254</li>
<li>12．5　Bloom效果　259</li>
<li>12．6　运动模糊　263</li>
<li>12．7　扩展阅读　266</li>
<li></li>
<li>第13章　使用深度和法线纹理　267</li>
<li>13．1　获取深度和法线纹理　267</li>
<li>13．1．1　背后的原理　267</li>
<li>13．1．2　如何获取　269</li>
<li>13．1．3　查看深度和法线纹理　271</li>
<li>13．2　再谈运动模糊　272</li>
<li>13．3　全局雾效　276</li>
<li>13．3．1　重建世界坐标　276</li>
<li>13．3．2　雾的计算　278</li>
<li>13．3．3　实现　278</li>
<li>13．4　再谈边缘检测　283</li>
<li>13．5　扩展阅读　287</li>
<li></li>
<li>第14章　非真实感渲染　288</li>
<li>14．1　卡通风格的渲染　288</li>
<li>14．1．1　渲染轮廓线　288</li>
<li>14．1．2　添加高光　289</li>
<li>14．1．3　实现　290</li>
<li>14．2　素描风格的渲染　293</li>
<li>14．3　扩展阅读　296</li>
<li>14．4　参考文献　297</li>
<li></li>
<li>第15章　使用噪声　298</li>
<li>15．1　消融效果　298</li>
<li>15．2　水波效果　302</li>
<li>15．3　再谈全局雾效　305</li>
<li>15．4　扩展阅读　309</li>
<li>15．5　参考文献　309</li>
<li></li>
<li>第16章　Unity中的渲染优化技术　310</li>
<li>16．1　移动平台的特点　310</li>
<li>16．2　影响性能的因素　311</li>
<li>16．3　Unity中的渲染分析工具　312</li>
<li>16．3．1　认识Unity 5的渲染统计</li>
<li>窗口　312</li>
<li>16．3．2　性能分析器的渲染区域　313</li>
<li>16．3．3　再谈帧调试器　313</li>
<li>16．3．4　其他性能分析工具　314</li>
<li>16．4　减少draw call数目　314</li>
<li>16．4．1　动态批处理　315</li>
<li>16．4．2　静态批处理　316</li>
<li>16．4．3　共享材质　318</li>
<li>16．4．4　批处理的注意事项　318</li>
<li>16．5　减少需要处理的顶点数目　319</li>
<li>16．5．1　优化几何体　319</li>
<li>16．5．2　模型的LOD技术　319</li>
<li>16．5．3　遮挡剔除技术　320</li>
<li>16．6　减少需要处理的片元数目　320</li>
<li>16．6．1　控制绘制顺序　320</li>
<li>16．6．2　时刻警惕透明物体　321</li>
<li>16．6．3　减少实时光照和阴影　321</li>
<li>16．7　节省带宽　322</li>
<li>16．7．1　减少纹理大小　322</li>
<li>16．7．2　利用分辨率缩放　323</li>
<li>16．8　减少计算复杂度　323</li>
<li>16．8．1　Shader的LOD技术　323</li>
<li>16．8．2　代码方面的优化　323</li>
<li>16．8．3　根据硬件条件进行缩放　324</li>
<li>16．9　扩展阅读　324</li>
<li>第5篇　扩展篇</li>
<li></li>
<li>第17章　Unity的表面着色器探秘　328</li>
<li>17．1　表面着色器的一个例子　328</li>
<li>17．2　编译指令　330</li>
<li>17．2．1　表面函数　330</li>
<li>17．2．2　光照函数　330</li>
<li>17．2．3　其他可选参数　331</li>
<li>17．3　两个结构体　332</li>
<li>17．3．1　数据来源：Input结构体　332</li>
<li>17．3．2　表面属性：SurfaceOutput</li>
<li>结构体　333</li>
<li>17．4　Unity背后做了什么　334</li>
<li>17．5　表面着色器实例分析　336</li>
<li>17．6　Surface Shader的缺点　341</li>
<li></li>
<li>第18章　基于物理的渲染　342</li>
<li>18．1　PBS的理论和数学基础　342</li>
<li>18．1．1　光是什么　343</li>
<li>18．1．2　双向反射分布函数</li>
<li>（BRDF）　344</li>
<li>18．1．3　漫反射项　345</li>
<li>18．1．4　高光反射项　346</li>
<li>18．1．5　Unity中的PBS实现　347</li>
<li>18．2　Unity 5的Standard Shader　348</li>
<li>18．2．1　它们是如何实现的　348</li>
<li>18．2．2　如何使用Standard Shader　349</li>
<li>18．3　一个更加复杂的例子　352</li>
<li>18．3．1　设置光照环境　352</li>
<li>18．3．2　放置反射探针　355</li>
<li>18．3．3　调整材质　356</li>
<li>18．3．4　线性空间　356</li>
<li>18．4　答疑解惑　357</li>
<li>18．4．1　什么是全局光照　357</li>
<li>18．4．2　什么是伽马校正　358</li>
<li>18．4．3　什么是HDR　361</li>
<li>18．4．4　那么，PBS适合什么样的</li>
<li>游戏　362</li>
<li>18．5　扩展阅读　363</li>
<li>18．6　参考文献　363</li>
<li></li>
<li>第19章　Unity 5更新了什么　365</li>
<li>19．1　场景“更亮了”　365</li>
<li>19．2　表面着色器更容易“报错了”　365</li>
<li>19．3　当家做主：自己控制非统一缩放的</li>
<li>网格　366</li>
<li>19．4　固定管线着色器逐渐退出舞台　366</li>
<li></li>
<li>第20章　还有更多内容吗　368</li>
<li>20．1　如果你想深入了解渲染的话　368</li>
<li>20．2　世界那么大　369</li>
<li>20．3　参考文献　369</li>
</ul>
<p>End.</p>
<p>Note by <a href="http://isayes.github.io" target="_blank" rel="external">HF</a>.  </p>
<hr>

      
    </div>
    <footer>
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>
<!-- hackish -->

  
</div>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2017 HuFei
  
</div>
<div class="clearfix"></div></footer>
  <script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="http://apps.bdimg.com/libs/fancybox/2.1.5/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>