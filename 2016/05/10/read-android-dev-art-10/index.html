<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title># 读 Android 开发艺术探索 &amp;10 | Notes.HF</title>
  <meta name="author" content="HuFei">
  
  <meta name="description" content="Notes of Daily Learning">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="# 读 Android 开发艺术探索 &amp;10"/>
  <meta property="og:site_name" content="Notes.HF"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Notes.HF" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
  
</head>

<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Notes.HF</a></h1>
  <h2><a href="/">notes of buaaGS1521AA9.hufei | 用来笔记一下</a></h2>
</div>
<nav id="main-nav">
  <ul>
    
      <li><a href="/more">分类</a></li>
    
      <li><a href="/works">作品</a></li>
    
      <li><a href="http://blog.csdn.net/heartyhu">博客</a></li>
    
      <li><a href="http://weibo.com/khufly">微博</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
<div class="alignleft" style="margin-top: 15px">


  <iframe src="http://ghbtns.com/github-btn.html?user=Isayes&type=follow"
  allowtransparency="true" frameborder="0" scrolling="0" width="132" height="20"></iframe>

</div>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="wrapper"><article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
  
    <h1 class="title"># 读 Android 开发艺术探索 &amp;10</h1>
  

      
        <p class="published">
          Published: <time datetime="2016-05-10T10:41:31.000Z">2016-05-10</time>
        </p>
      
    </header>
    <div class="entry">
      
        <p>关键词：四大组件 / Activity / Service / BroadcastReceiver / ContentProvider</p>
<p>本次笔记主要梳理了四大组件的进一步认识，为今后更进一步了解四大组件的工作原理做个准备，温故知新、查漏补缺。</p>
<a id="more"></a>
<p>Android 四大组件中除了 BroadcastReceiver 以外，其它三种组件都必须只在 AndroidManifest 中注册，而 BroadcastReceiver 既可以在 Manifest 中注册也可以通过代码来注册。Activity、Service、BroadcastReceiver 需要借助 Intent 来调用，而 ContentProvider 无需借助 Intent。</p>
<h2 id="1-Activity"><a href="#1-Activity" class="headerlink" title="1. Activity #"></a>1. Activity #</h2><ol>
<li>Activity 是一个展示型的组件；</li>
<li>Activity 的启动由 Intent 来触发，其中 Intent 分为显示和隐式，显示 Intent 可以明确地指向一个 Activity 组件，隐式 Intent 则指向一个或多个目标 Activity 甚至没有任何一个 Activity 组件可以处理这个隐式 Intent；</li>
<li>Activity 组件的主要作用是展示一个界面并和用户交互，扮演着前台界面的角色；</li>
<li>Activity 只有一种运行模式，即 Activity 处于启动状态；</li>
</ol>
<h2 id="2-Service"><a href="#2-Service" class="headerlink" title="2. Service #"></a>2. Service #</h2><ol>
<li>Service 是一种计算型组件，用于后台执行一系列计算任务；</li>
<li>Service 组件工作在后台，用户无法感知；</li>
<li>Service 组件不同于 Activity，它有两种状态：启动状态 和 绑定状态；</li>
<li>Service 处于启动状态的时候，Service 内部做一些后台计算，不需和外界有直接的交互。不过，Service 组件本身是运行在主线程中的，耗时的后台计算仍然需要在单独的线程中去完成；</li>
<li>Service 处于绑定状态的时候，Service 内部同样可以做一些后台计算，并且可以很方便地和 Service 组件进行通信；</li>
<li>停止一个 Service 需要灵活采用 stopService 和 unBindService 这两个方法才能完全停止一个 Service 组件；</li>
</ol>
<p>强调一下 Service 的两种状态：<br>启动状态 —— 主要用于执行后台计算；<br>绑定状态 —— 主要用于其它组件和 Service 的交互；<br>这两种状态是可以共存的，既可以处于启动状态也可以同时处于绑定状态。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent intentService = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyService.class);</span><br><span class="line">startService(intentService);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent intentService = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyService.class);</span><br><span class="line">bindService(intentService, mServiceConnection, BIND_AUTO_CREATE);</span><br></pre></td></tr></table></figure>
<p>来了解一下 Google 官方的说明：  </p>
<p>对于 startService：<br>Once started, a service can run in the background indefinitely, even if the component that started it is destroyed. Usually, a started service performs a single operation and does not return a result to the caller. For example, it might download or upload a file over the network. When the operation is done, the service should stop itself.<br>用 startService 启动，这个 Service 不会跟随者启动它的 component 消减，而且原则上不能与 UI 互动；</p>
<p>对于 bindService：<br>A bound service offers a client-server interface that allows components to interact with the service, send requests, get results, and even do so across processes with interprocess communication (IPC). A bound service runs only as long as another application component is bound to it. Multiple components can bind to the service at once, but when all of them unbind, the service is destroyed.<br>用 bindService 的情况下，此 service 可以跟 component 进行沟通，甚至可以做到 IPC</p>
<p>小结：<br>bindService 和 startService 最主要的差别在于其本身的 LifeCycle 以及 bindService 可以用来做 IPC（可以让你的 service 和 UI 沟通）</p>
<h2 id="3-BroadcastReceiver"><a href="#3-BroadcastReceiver" class="headerlink" title="3. BroadcastReceiver #"></a>3. BroadcastReceiver #</h2><ol>
<li>BroadcastReceiver 是一种消息型组件；</li>
<li>BroadcastReceiver 用于在不同的组件乃至不同的应用之间传递消息；</li>
<li>工作在系统内部，用户不感知；</li>
<li>BroadcastReceiver 有两种注册的方式：静态注册 和 动态注册；</li>
<li>静态注册在 manifest 里注册广播，在应用安装时就会被系统解析，不需要应用启动就可以收到相应广播；</li>
<li>动态注册通过 Context.registerReceiver() 来实现，不需要时通过 Context.unRegisterReceiver() 来解除广播，这种注册方式必须要应用启动才能注册并接收广播；</li>
<li>通过 Context 的一系列 send 方法来发送广播，被发送的广播会被系统发送给感兴趣的广播接受者，发送和接收过程的匹配是通过广播接受者的 <intent-filter> 来描述的；</intent-filter></li>
<li>BroadcastReceiver 不适合用来执行耗时的操作；</li>
<li>BroadcastReceiver 没有停止的概念，不需要停止；</li>
</ol>
<p>当通过 send 方法来发送广播的时候，AMS 会查找出匹配的广播接收者并将广播发送给它们处理。<br>广播发送的几种类型有：普通广播、有序广播和粘贴广播；它们的发送/接收过程是类似的；  </p>
<h2 id="4-ContentProvider"><a href="#4-ContentProvider" class="headerlink" title="4. ContentProvider #"></a>4. ContentProvider #</h2><ol>
<li>ContentProvider 是一种数据共享型组件，通过 Binder 用于向其它组件乃至其它应用共享数据；</li>
<li>ContentProvider 无法被用户感知，不需要手动停止；</li>
<li>ContentProvider 的内部需要实现 增 删 改 查 这四种操作；</li>
<li>ContentProvider 内部维持着一份数据集合，可以通过数据库、List、Map 等来实现；</li>
<li>ContentProvider 内部的 insert / delete / update / query 方法需要处理好线程同步，因为这几个方法是在 Binder 线程池中被调用</li>
</ol>
<p>当 ContentProvider 所在的进程启动的时候，ContentProvider 的 onCreate 要先于 Application 的 onCreate 而执行，这在四大组件中是一个很少有的现象；</p>
<p>End.</p>
<p>Note by <a href="http://isayes.github.io" target="_blank" rel="external">HF</a>.<br>Learn from 《Android 开发艺术探索》</p>
<hr>

      
    </div>
    <footer>
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>
<!-- hackish -->

  
</div>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2017 HuFei
  
</div>
<div class="clearfix"></div></footer>
  <script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="http://apps.bdimg.com/libs/fancybox/2.1.5/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>