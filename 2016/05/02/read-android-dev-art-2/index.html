<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title># 读 Android 开发艺术探索 &amp;2 | Notes.HF</title>
  <meta name="author" content="HuFei">
  
  <meta name="description" content="Notes of Daily Learning">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="# 读 Android 开发艺术探索 &amp;2"/>
  <meta property="og:site_name" content="Notes.HF"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Notes.HF" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
  
</head>

<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Notes.HF</a></h1>
  <h2><a href="/">notes of buaaGS1521AA9.hufei | 用来笔记一下</a></h2>
</div>
<nav id="main-nav">
  <ul>
    
      <li><a href="/more">分类</a></li>
    
      <li><a href="/works">作品</a></li>
    
      <li><a href="http://www.cnblogs.com/isayes">博客</a></li>
    
      <li><a href="http://weibo.com/khufly">微博</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
<div class="alignleft" style="margin-top: 15px">


  <iframe src="http://ghbtns.com/github-btn.html?user=Isayes&type=follow"
  allowtransparency="true" frameborder="0" scrolling="0" width="132" height="20"></iframe>

</div>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="wrapper"><article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
  
    <h1 class="title"># 读 Android 开发艺术探索 &amp;2</h1>
  

      
        <p class="published">
          Published: <time datetime="2016-05-02T11:00:10.000Z">2016-05-02</time>
        </p>
      
    </header>
    <div class="entry">
      
        <p>关键词：IPC / 多进程 / 序列化 / Binder  </p>
<p>IPC，Inter-Process Communication 的缩写，含义为进程间通信或者跨进程通信，两个进程之间进行数据交换的过程。说到 IPC 的使用场景，就要提到多进程，当采用了多进程的设计方法，那么应用中就必须妥善处理进程间通信的各种问题。<br><a id="more"></a></p>
<p>[ 首先必须知道的几点：]</p>
<ol>
<li>进程：一般是指一个执行单元，在 PC 和移动设备中指一个程序或者一个应用。</li>
<li>线程：CPU 调度的最小单元，是一种有限的系统资源。</li>
<li>一个进程可以包含多个线程，包含与被包含的关系。</li>
<li>一个进程可只有一个线程，主线程，在 Android 中就是 UI 线程，只有在 UI 线程里才能对界面元素进行操作。</li>
<li>ANR，Application Not Responding，应用无响应，防止ANR，把耗时的任务放在子线程中执行。</li>
<li>Android 有自己的进程间通信方式：Binder / Socket</li>
<li>通过系统提供的 ContentProvider 去查询数据的时候也是一种进程间通信，只不过通信细节被系统屏蔽了。</li>
</ol>
<h2 id="1-Android-中的多进程模式"><a href="#1-Android-中的多进程模式" class="headerlink" title="1. Android 中的多进程模式 #"></a>1. Android 中的多进程模式 #</h2><p>在 Android 中使用多进程的常用方法只有一种：给四大组件在 AndroidManifest 中指定 android:process 属性。示例：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">"io.github.isayes.MainActivity"</span></span><br><span class="line">    <span class="attr">...</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">"io.github.isayes.SecondActivity"</span>  </span><br><span class="line">    <span class="attr">android:process</span>=<span class="string">":remote"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">"io.github.isayes.ThirdActivity"</span></span><br><span class="line">    <span class="attr">android:process</span>=<span class="string">"io.github.isayes.remote"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>[ 需要知道以下几点：]</p>
<ol>
<li>启动 SecondActivity 的时候系统会为它创建一个单独的进程：“io.github.isayes:remote”;  </li>
<li>启动 ThirdActivity 的时候系统为它创建一个单独的进程：“io.github.isayes.remote”；  </li>
<li>入口的 MainActivity 运行在默认的进程中，默认的进程名为包名；  </li>
<li>进程名以 “:” 开头说明进程属于当前应用的私有进程（其它应用的组件不可以与之跑在同一个进程中），不以之开头的进程是全局进程（其它应用通过 ShareUID 方式与之可以跑在同一个进程中）；</li>
<li>Android 系统会为每个应用分配一个唯一的 UID，UID 相同才能共享数据（data 目录、组件信息等私有数据）；UID 相同并且签名相同才能跑在同一个进程中（还可以共享内存数据）。</li>
</ol>
<p>Android 系统为每一个应用分配了一个独立的虚拟机，或者说为每一个进程都分配了一个独立的虚拟机，不同的虚拟机在内存分配上有不同的地址空间，导致在不同的虚拟机中访问同一个类的对象会产生多份副本。一般来说，使用多线程会导致以下几个需要注意的问题 ↓  </p>
<ol>
<li>静态成员和单例模式失效</li>
<li>线程同步机制失效</li>
<li>SharedPreferences 的可靠性下降</li>
<li>Application 会多次创建（运行在同一个进程中的组件是属于同一个虚拟机和同一个 Application 的，同理，运行在不同的进程中的组件是属于不同的两个虚拟机和不同的 Application ）</li>
<li>在多进程模式中，不同的进程的组件会有独立的虚拟机，独立的Application 以及内存空间；</li>
</ol>
<p>理解同一个应用间的多进程：相当于两个不同的应用采用了 ShareUID 的模式。<br>为了解决多进程带来的问题，系统提供了很多跨进程通信的方法，虽然不能直接的共享内存，但是通过跨进程通信可以实现数据交互。实现跨进程通信的方式有：  </p>
<ol>
<li>通过 Intent 传递数据</li>
<li>共享文件</li>
<li>SharedPreferences</li>
<li>基于  Binder 的 Messenger 和 AIDL</li>
<li>Socket 等</li>
</ol>
<p>要理解 IPC 的各种方式，需要熟悉一些基础概念：序列化相关的 Serializable / Parcelable 接口 和 Binder</p>
<h2 id="2-IPC-基础-相关概念"><a href="#2-IPC-基础-相关概念" class="headerlink" title="2. IPC 基础 相关概念 #"></a>2. IPC 基础 相关概念 #</h2><table>
<thead>
<tr>
<th>IPC 的基础概念有三点：</th>
</tr>
</thead>
<tbody>
<tr>
<td>1. Serializable</td>
</tr>
<tr>
<td>2. Parcelable</td>
</tr>
<tr>
<td>3. Binder</td>
</tr>
</tbody>
</table>
<p>Serializable 和 Parcelable 接口完成对象的序列化过程，当我们通过 Intent 和 Binder 传输数据时就需要使用 Parcelable 或者 Serializable。</p>
<p>若需要把对象持久化到存储设备上或者通过网络传输给其他客户端，这时候也需要使用 Serializable 来完成对象的持久化。</p>
<p>【关于 Serializable 需要知道的几点】</p>
<ol>
<li>Java 提供的序列化接口，是一个空接口</li>
<li>为对象提供标准的序列化和反序列化操作</li>
<li>几乎所有的工作都被系统自动完成了</li>
<li>静态成员变量属于类不属于对象，所以不会参与序列化过程</li>
<li>采用 transient 关键字标记的成员变量不参与序列化过程</li>
<li><code>private static final long serialVersionUID = -1589804003600796026L;</code><br>serialVersionUID 辅助序列化和反序列化过程，序列化后的数据的 serialVersionUID 要和 当前类的 serialVersionUID 相等才能被正常地反序列化</li>
</ol>
<p>【关于 Parcelable 需要知道的几点】</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法 / 功能 / 标记位</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">createFromParcel(Parcel in) / 从序列化后的对象中创建原始对象 /</td>
</tr>
<tr>
<td style="text-align:left">newArray(int size) / 创建指定长度的原始对象数组 /</td>
</tr>
<tr>
<td style="text-align:left">User(Parcel in) / 从序列化后的对象中创建原始对象 /</td>
</tr>
<tr>
<td style="text-align:left">writeToParcel(Parcel out, int flags) / 将当前对象写入序列化结构中，其中 flags 标识有两种值：0 或 1，为 1 时标识当前对象需要作为返回值返回，不能立即释放资源，几乎所有情况都为 0 / PARCELABLE_WRITE_RETURN_VALUE</td>
</tr>
<tr>
<td style="text-align:left">describeContents / 返回当前对象的内容描述。如果含有文件描述符，返回 1，否则返回 0， 几乎所有情况都返回 0 / CONTENTS_FILE_DESCRIPTOR</td>
</tr>
</tbody>
</table>
<p>[ 对 Parcelable 的典型用法示例 ]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Parcelable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> userId;</span><br><span class="line">    <span class="keyword">public</span> String userName;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isMale;</span><br><span class="line">    <span class="keyword">public</span> Book book;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> userId, String userName, <span class="keyword">boolean</span> isMale)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userId = userId;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">        <span class="keyword">this</span>.isMale = isMale;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内容描述功能</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化功能的完成，最终通过 Pacel 中的一系列 write 方法来完成</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel out, <span class="keyword">int</span> flags)</span></span>&#123;</span><br><span class="line">        out.wirteInt(userId);</span><br><span class="line">        out.writeString(userName);</span><br><span class="line">        out.writeInt(isMale ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        out.writeOarcelable(book, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化功能的完成</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Parcelable.Creator&lt;User&gt; CREATOR = <span class="keyword">new</span> Parcelable.Creator&lt;User&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> User <span class="title">createFromParcel</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> User(in);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> User[] newArray(<span class="keyword">int</span> size)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> User[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">User</span><span class="params">(Parcel in)</span></span>&#123;</span><br><span class="line">        userId = in.readInt();</span><br><span class="line">        userName = in.readString();</span><br><span class="line">        isMale = in.readInt() == <span class="number">1</span>;</span><br><span class="line">        book = in.readParcelable(Thread.currentThread().getContextClass-Loader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>[ 对两种序列化接口的比较：]</p>
<table>
<thead>
<tr>
<th>Serializable / Parcelable</th>
</tr>
</thead>
<tbody>
<tr>
<td>Serializable 是 Java 提供的序列化接口 / Parcelable 是 Android 提供的序列化接口，更适合在 Android 平台上</td>
</tr>
<tr>
<td>Serializable 使用简单但是开销大，序列化和反序列化过程中需要大量的 IO 操作 / Parcelable 使用麻烦但是效率很高</td>
</tr>
</tbody>
</table>
<p>【Binder】</p>
<p>需要知道的几点 ↓  </p>
<ol>
<li>Binder 是 Android 的一个实现了 IBinder 接口的类。</li>
<li>是 Android 的一种跨进程通信方式</li>
<li>是一种虚拟的物理设备，设备驱动是 /dev/binder</li>
<li>从 Android Framework 角度来看，Binder 是 ServiceManager 连接各种 Manager（ActivityManager、WindowManager 等等）和相应的 ManagerService 的桥梁。</li>
<li>从 Android 应用层来说，是客户端和服务端进行通信的媒介</li>
<li>Binder 主要用在 Service 中，包括 AIDL、Messenger（底层也是 AIDL）</li>
<li>所有可以在 Binder 中传输的接口都需要继承 IInterface 接口</li>
</ol>
<p>关于 Binder 的知识需要单独总结一下：<a href="http://isayes.github.io/2016/05/10/read-android-dev-art-3/" target="_blank" rel="external">读 Android 开发艺术探索 &amp;3 （番外篇之弄懂 Binder）</a></p>
<p>End.</p>
<p>Note by HF.<br>Learn from 《Android 开发艺术探索》</p>
<hr>
<p>本文标签：<a href="http://isayes.github.io/categories/android" target="_blank" rel="external">Android</a></p>

      
    </div>
    <footer>
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>
<!-- hackish -->

  
</div>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2017 HuFei
  
</div>
<div class="clearfix"></div></footer>
  <script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="http://apps.bdimg.com/libs/fancybox/2.1.5/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>