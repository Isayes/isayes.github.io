<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title># C井中常用的容器与底层数据结构 | Notes.HF</title>
  <meta name="author" content="HuFei">
  
  <meta name="description" content="Notes of Daily Learning">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="# C井中常用的容器与底层数据结构"/>
  <meta property="og:site_name" content="Notes.HF"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Notes.HF" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
  
</head>

<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Notes.HF</a></h1>
  <h2><a href="/">notes of buaaGS1521AA9.hufei | 用来笔记一下</a></h2>
</div>
<nav id="main-nav">
  <ul>
    
      <li><a href="/more">分类</a></li>
    
      <li><a href="/works">作品</a></li>
    
      <li><a href="http://blog.csdn.net/heartyhu">博客</a></li>
    
      <li><a href="http://weibo.com/khufly">微博</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
<div class="alignleft" style="margin-top: 15px">


  <iframe src="http://ghbtns.com/github-btn.html?user=Isayes&type=follow"
  allowtransparency="true" frameborder="0" scrolling="0" width="132" height="20"></iframe>

</div>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="wrapper"><article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
  
    <h1 class="title"># C井中常用的容器与底层数据结构</h1>
  

      
        <p class="published">
          Published: <time datetime="2017-01-16T07:24:51.000Z">2017-01-16</time>
        </p>
      
    </header>
    <div class="entry">
      
        <p>Array / ArrayList / List / LinkedList / HashSet / HashTable / Dictionary<br><a id="more"></a></p>
<h2 id="1-Array"><a href="#1-Array" class="headerlink" title="1. Array"></a>1. Array</h2><p>数组. 在内存中连续存储, 它的索引速度很快, 而且赋值与修改元素简单.</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span>[] s = <span class="keyword">new</span> <span class="keyword">string</span>[<span class="number">2</span>];</span><br><span class="line"><span class="comment">// 赋值</span></span><br><span class="line">s[<span class="number">0</span>] = <span class="string">"a"</span>;</span><br><span class="line">s[<span class="number">1</span>] = <span class="string">"b"</span>;</span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line">s[<span class="number">1</span>] = <span class="string">"a1"</span>;</span><br></pre></td></tr></table></figure>
<p>数组的不足 : 数组的两个数据之间插入数据很麻烦 , 而且声明数组时需要指定长度 , 长度过长造成内存浪费 , 过短造成数据溢出的错误 . 克服这些缺点有 ArrayList , 但是 ArrayList 底层数据结构也是数组 .</p>
<h2 id="2-ArrayList"><a href="#2-ArrayList" class="headerlink" title="2. ArrayList"></a>2. ArrayList</h2><p>引用自 System.Collections , 继承了 IList 接口 , 提供了数据存储和检索 . ArrayList 对象的大小按照其中存储的数据来动态扩充与收缩 . 声明 ArrayList 不需要指定长度 .</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="comment">// 新增数据</span></span><br><span class="line">list.Add(<span class="string">"abc"</span>);</span><br><span class="line">list.Add(<span class="string">"def"</span>);</span><br><span class="line">list.Add(<span class="number">567</span>);</span><br><span class="line"><span class="comment">// 修改数据</span></span><br><span class="line">list[<span class="number">2</span>] = <span class="number">34</span>;</span><br><span class="line"><span class="comment">// 移除数据</span></span><br><span class="line">list.RemoveAt(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 插入数据</span></span><br><span class="line">list.Insert(<span class="number">0</span>, <span class="string">"qwe"</span>);</span><br></pre></td></tr></table></figure>
<p>在 ArrayList 中插入不同类型的数据是允许的 , ArrayList 把所有的数据当做 Object 类型来处理 . 在我们使用 ArrayList 处理数据时，很可能会报类型不匹配的错误，也就是 ArrayList 不是类型安全的。在存储或检索值类型时通常发生装箱和取消装箱操作，带来很大的性能耗损。</p>
<p>装箱 : 将数值类型打包到引用类型的实例中<br>拆箱 : 从引用数据中提取值类型</p>
<h2 id="3-泛型-List"><a href="#3-泛型-List" class="headerlink" title="3.  泛型 List"></a>3.  泛型 List</h2><p>因为 ArrayList 存在不安全类型与装箱拆箱的缺点 , 所以出现了泛型的概念 . 大部分用法都与 ArrayList 相似，因为 List 类也继承了 IList 接口。最关键的区别在于，在声明 List 集合时，我们同时需要为其声明 List 集合内数据的对象类型。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="keyword">string</span>&gt; list = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line"><span class="comment">// 新增数据</span></span><br><span class="line">list.Add(<span class="string">"abc"</span>);</span><br><span class="line"><span class="comment">// 修改数据</span></span><br><span class="line">list[<span class="number">0</span>] = <span class="string">"def"</span>;</span><br><span class="line"><span class="comment">// 移除数据</span></span><br><span class="line">list.RemoveAt(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>避免了类型安全问题与装箱拆箱的性能问题 , 类似于 C++ 里面的 Vector .</p>
<h2 id="4-LinkedList"><a href="#4-LinkedList" class="headerlink" title="4. LinkedList"></a>4. LinkedList</h2><p>用双链表实现的 List , 特点是插入删除块 , 查找慢 .</p>
<p>LinkedList<t> 提供 LinkedListNode<t> 类型的单独节点 , 插入和移除的运算复杂度为 O(1) .</t></t></p>
<p>LinkedList<t> 对象中每个节点都属于 LinkedListNode<t> 类型 . 由于 LinkedList<t> 是双向链表 , 因此每个节点向前指向 Next 节点 , 向后指向 Previous 节点 .</t></t></t></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;<span class="keyword">string</span>&gt; list = <span class="keyword">new</span> LinkedList&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line">list.AddFirst(<span class="string">"Data Value 1"</span>);</span><br><span class="line">list.AddLast(<span class="string">"Data Value 6"</span>);</span><br></pre></td></tr></table></figure>
<p>在 List<t> 中增加、删除节点的速度，大体上快于使用 LinkedList<t> 时的相同操作。<br>一个 List<t> 性能优于 LinkedList<t> 的地方是你在使用索引进行访问的时候。在 List<t> 中，你可以使用索引值（indexer）直接定位到某个具体的元素位置。而在 LinkedList<t> 中，却没有这样的奢侈品。在 LinkedList<t> 中，你必须通过 Previous 或 Next 属性遍历整个 List，直到找到你想要的节点。</t></t></t></t></t></t></t></p>
<h2 id="5-HashSet"><a href="#5-HashSet" class="headerlink" title="5. HashSet"></a>5. HashSet</h2><p>HashSet / HashTable / Dictionary 这三个容器的底层都是 Hash 表。</p>
<p>HashSet : 表示值的集合 . HashSet<t> 类提供了高性能的集运算 . 一组是一个集合，不包含任何重复的元素，且的元素顺序不分先后。用了 Hash Table 来储存数据，是为了用 O(n) 的 space 来换取 O(n) 的时间，也就是查找元素的时间是 O(1)。</t></p>
<p>HashSet<t> 提供了许多数学设置操作 . 比如</t></p>
<p><code>UnionWith - 联合
  IntersectWith - 交集
  ExceptWith - Set 减法
  SymmetricExceptWith - 余集</code></p>
<p>例子:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HashSet&lt;<span class="keyword">int</span>&gt; evenNumbers = <span class="keyword">new</span> HashSet&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">HashSet&lt;<span class="keyword">int</span>&gt; oddNumbers = <span class="keyword">new</span> HashSet&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">  evenNumbers.Add(i*<span class="number">2</span>);</span><br><span class="line">  oddNumbers.Add((i*<span class="number">2</span>)+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">HashSet&lt;<span class="keyword">int</span>&gt; numbers = <span class="keyword">new</span> HashSet&lt;<span class="keyword">int</span>&gt;(evenNumbers);</span><br><span class="line">numbers.UnionWith(oddNumbers);</span><br></pre></td></tr></table></figure>
<h2 id="6-HashTable"><a href="#6-HashTable" class="headerlink" title="6. HashTable"></a>6. HashTable</h2><p>表示根据键的哈希代码进行组织的 键/值对 的集合。用于处理和表现类似 key/value 的键值对，其中 key 通常可用来快速查找，同时 key 是区分大小写；value 用于存储对应于 key 的值。Hashtable 中 key/value 键值对均为 object 类型，所以 Hashtable 可以支持任何类型的 key/value 键值对.</p>
<p>他内部维护很多对 Key-Value 键值对，其还有一个类似索引的值叫做散列值(HashCode)，它是根据 GetHashCode 方法对 Key 通过一定算法获取得到的，所有的查找操作定位操作都是基于散列值来实现找到对应的 Key 和 Value 值的</p>
<p>当前 HashTable 中的被占用空间达到一个百分比的时候就将该空间自动扩容，在 .net 中这个百分比是 72%,也叫 .net 中 HashTable 的填充因子为 0.72。例如有一个 HashTable 的空间大小是 100，当它需要添加第 73 个值的时候将会扩容此 HashTable.</p>
<p>这个自动扩容的大小是多少呢？答案是当前空间大小的两倍最接近的素数，例如当前 HashTable 所占空间为素数 71，如果扩容，则扩容大小为素数 131.</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HashTable openWith = <span class="keyword">new</span> HashTable();</span><br><span class="line">openWith.Add(<span class="string">"txt"</span>, <span class="string">"notepad.exe"</span>);</span><br><span class="line">openWith.Add(<span class="string">"bmp"</span>, <span class="string">"paint.exe"</span>);</span><br><span class="line">openWith.Add(<span class="string">"dib"</span>, <span class="string">"paint.exe"</span>);</span><br><span class="line">openWith.Add(<span class="string">"rtf"</span>, <span class="string">"wordpad.exe"</span>);</span><br></pre></td></tr></table></figure>
<p>HashTable 也有拆箱装箱的开销 .</p>
<h2 id="7-Dictionary"><a href="#7-Dictionary" class="headerlink" title="7. Dictionary"></a>7. Dictionary</h2><p>也是键值容器, 存入对象需要与 key 值一一对应的存入该泛型, 相对于 HashTable, 类似于 List 和 ArrayList 的关系, 它是类型安全的.</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">string</span>&gt; myDic = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">string</span>&gt;();</span><br><span class="line">myDic.Add(<span class="string">"aaa"</span>, <span class="string">"111"</span>);</span><br><span class="line">myDic.Add(<span class="string">"bbb"</span>, <span class="string">"222"</span>);</span><br><span class="line">myDic.Add(<span class="string">"ccc"</span>, <span class="string">"333"</span>);</span><br><span class="line">myDic.Add(<span class="string">"ddd"</span>, <span class="string">"444"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h2><p>在决定使用 List<t> 还是使用 ArrayList 类（两者具有类似的功能）时，记住 List<t> 类在大多数情况下执行得更好并且是类型安全的。如果对 List&lt; T&gt; 类的类型 T 使用引用类型，则两个类的行为是完全相同的。但是，如果对类型T使用值类型，则需要考虑实现和装箱问题。所以不怎么用 ArrayList.</t></t></p>
<p>在单线程的时候使用 Dictionary 更好一些，多线程的时候使用 HashTable 更好。因为 HashTable 可以通过 <code>Hashtable tab = Hashtable.Synchronized(new Hashtable());</code> 获得线程安全的对象。</p>
<p>End.</p>

      
    </div>
    <footer>
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>
<!-- hackish -->

  
</div>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2017 HuFei
  
</div>
<div class="clearfix"></div></footer>
  <script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="http://apps.bdimg.com/libs/fancybox/2.1.5/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>